# Demo of IDA

## Installation steps

To install IDA, you can follow these steps:

**On Windows:**

Simply click on the following link and Install the [Windows Installer](https://hex-rays.com/ida-free/#download).

**On Linux :**

- Install dependencies :

```
sudo apt-get install --reinstall libxcb-xinerama0
```

- Download IDA Free

```
wget https://out7.hex-rays.com/files/idafree84_linux.run
```

- Provide necessary permission

```
chmod +x idafree84_linux.run
```

- Start the installation process

```
./idafree84_linux.run
```

- Launch it

```
cd /opt/idafree-8.4
./ida64
```

## Reversing a PIN Checker

Its time to pratice! We are going to reverse engineering this [little script](https://mega.nz/#!PXYjCKCY!F2gcs83XD6RxjOR-FNWGQZpyvUFvDbuT-PTnqRhBPGQ) . We can try to run it manually. We observe that you need to enter a pin for this to work. If you enter any random input it will output “PIN Salah!” Clearly we want to find the PIN which gives the other possibility.

```
┌──(kali㉿kali)-[~/Downloads]
└─$ chmod u+x rev1

┌──(kali㉿kali)-[~/Downloads]
└─$ ./rev1
Masukan PIN = 1234
PIN salah !
```

Lets go deeper in this by using IDA.

- First of all launch it and select "new project"

![IDA_New_Project](https://cyber-lead-assets.s3.amazonaws.com/M03-Incident_Management/D04-Reverse_Engineering/01-lectures/IDA_New_Project.png)

- Keep every settings as default and just press `OK`

![Import_Settings](https://cyber-lead-assets.s3.amazonaws.com/M03-Incident_Management/D04-Reverse_Engineering/01-lectures/Import_Settings.png)

- If everything worked correctly you should get the following interface.

![Home_Page_IDA](https://cyber-lead-assets.s3.amazonaws.com/M03-Incident_Management/D04-Reverse_Engineering/01-lectures/Home_Page_IDA.png)

<Note type="tip">
## Reminder

**The `MOV` Instruction:**

```
MOV AX, 1  ; Moves the value 1 into the AX register
MOV BX, AX ; Moves the value from AX to BX
```

**Data Types:**

```
DB  'Data Byte'	; 8 bits
DW  'Data Word'	; 16 bits
DD  'Double Word'	; 32 bits
```

**Conditional Operations:**

```
CMP AX, 1  ; Compares AX with 1
JE  LABEL1 ; Jumps to LABEL1 if AX is equal to 1
JNE LABEL2 ; Jumps to LABEL2 if AX is not equal to 1
```

</Note>

As we can see the below branches show us the other possibility, so if we send the good pin we should obtain `PIN benar!`. Observe that via `test` the only way we can get “PIN Salah!” is if `EAX` held the value 0.

![Zoom_Main](https://cyber-lead-assets.s3.amazonaws.com/M03-Incident_Management/D04-Reverse_Engineering/01-lectures/Zoom_Main.png)

When we enter the wrong PIN, `EAX` is set to `0`. Notice the instruction `call cek`. In assembly, `call` means that a function is being invoked. Double-click on this instruction to view the code for the `cek` function.

![Second_Graph](https://cyber-lead-assets.s3.amazonaws.com/M03-Incident_Management/D04-Reverse_Engineering/01-lectures/Second_Graph.png)

An important point in reverse engineering is to avoid analyzing every detail, as much of the code is generated by the compiler and can be difficult to interpret. Instead, focus on understanding the overall structure and operation of the program.

Looking at the `cek` block, after all the initial processing, there are two possible outcomes. One path sets `eax` to `1`, while the other sets it to `0`. Our goal is to determine when `eax` is set to `1`, as this indicates the correct PIN.

The branching decision is controlled by the `jnz` instruction, which stands for "jump if not zero." Since the program uses a `cmp` instruction, it means that the jump will only occur when the zero flag is not set—resulting in `EAX` being set to `1`.

So, when is the zero flag set? This happens only when `[rbp+var_4]` equals `eax`. The preceding `mov` instructions indicate that the value now in `[rbp+var_4]` is the same as the value in `edi`, and the value in `eax` originates from a location referred to as `cs:valid`.

What is `cs:valid`? It’s simply a label assigned by IDA to a specific value stored in the binary. If we double-click on this label, we can see the following value data:

![secret_value](https://cyber-lead-assets.s3.amazonaws.com/M03-Incident_Management/D04-Reverse_Engineering/01-lectures/secret_value.png)

We finally found were the secret pass is getting stored. The value seems to be `51615h` (which is given in hex) if we go back to the structure of the program, this value should make it possible to have `1` in `EAX` field and validate the test ! So let's try it.

First convert this to decimal so that it can be entered manually when the script is run, just like a normal pin code.

![Hex_to_decimal](https://cyber-lead-assets.s3.amazonaws.com/M03-Incident_Management/D04-Reverse_Engineering/01-lectures/Hex_to_decimal.png)

The equivalent is `333333`. Now all we have to do is test it and see what wheter this is correct or not.

```
┌──(kali㉿kali)-[~/Downloads]
└─$ ./rev1
Masukan PIN = 333333
PIN benar !
```

Yes it is, we get the correct string return who is `PIN benar !`.
