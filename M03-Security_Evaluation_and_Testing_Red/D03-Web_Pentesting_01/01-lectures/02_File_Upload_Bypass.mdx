# File Upload Bypass

## What you will learn in this course 🧐🧐

- Understanding the File Upload Bypass vulnerability
- Learn to exploit File Upload Bypass vulnerabilities

The ability to import files from a server is often essential for many web applications, such as sharing documents, adding attachments or allowing users to download multimedia content. It can enhance the user experience and extend the functionality of an application. However, this functionality represents a critical vulnerability, as it potentially allows malicious files to be imported directly onto the server, compromising the security of the entire system.

## Description

The ‘File Upload Bypass’ flaw exists mainly because of flaws in the validation and management of files uploaded to a server. Developers may not correctly implement security checks to verify the extension, MIME type or actual content of the file, allowing an attacker to bypass these restrictions and import malicious files. This flaw can be exploited to inject malicious code, access sensitive data or take control of the server.

1. The attacker uploads a file with a seemingly harmless extension like .jpg or .txt.

2. Once uploaded, the attacker manipulates the server to execute this file, often by changing its extension or exploiting server misconfigurations.

3. If successful, the file can run malicious code, giving the attacker control over the server.

![File_Upload_Bypass](https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D04-Web_Pentesting_01/01-lectures/File_Upload_Bypass.png)

## Exploitation

An attacker exploits this vulnerability by bypassing the server's file upload validation mechanisms. This can be done through several methods, such as changing file extensions, manipulating content-type headers, or using double extensions (e.g., `malware.php.jpg`). The attacker might also use specially crafted files that exploit weaknesses in the validation logic, such as exploiting null byte injections to bypass file type checks or by exploiting MIME-type vulnerabilities (where the extension appears legitimate but the content is dangerous). Once the malicious file is uploaded, it can be executed to perform unauthorized actions, such as compromising the server, exfiltrating data, or spreading malware.

There are several ways to verify a file's extensions, and thus several ways to bypass these checks. Here are the most common techniques to test:

### Bypassing File Extension Checks

The first and primary check that exists is to verify the extension of the file that is being uploaded.

For example, the code shown below contains a security flaw relating to the checking of file extensions before they are downloaded. Although the script implements a blacklist (`$blacklist_ext`) to block certain dangerous extensions such as ‘php’, ‘phtml’, or ‘phar’, it remains vulnerable to simple evasion techniques.

```php
$target_dir = "uploads/";
$blacklist_ext = ["php", "php4", "php5", "phtm", "phtml", "phar"];

// Check if the client tries to upload a new document to be shared with others:
if( $_SERVER['REQUEST_METHOD'] == "POST" && isset($_POST["submit"]) ) {
    $target_file = $target_dir . basename($_FILES["filedoc"]["name"]);

    $ext = strtolower(  pathinfo($target_file, PATHINFO_EXTENSION) );

    if ( in_array($ext, $blacklist_ext) ) {
        echo "You got caught!";
        die();
    }

    //Upload the file to the given directory
    if ( move_uploaded_file($_FILES["filedoc"]["tmp_name"], $target_file) ) {
        echo 'The document was uploaded successfully : ' . htmlspecialchars($target_file);
    }
}
```

To bypass this, you can try using these different techniques:

1. **Alternative Extensions**: Use different extensions that the server might execute, such as `.php`, `.asp`, `.jsp`, etc.
2. **Case Sensitivity**: Use uppercase letters in extensions like `.pHp`, `.PhAr`.
3. **Double Extensions**: Use extensions like `file.png.php`.
4. **Special Characters**: Add characters like `%20`, `%00`, or `/` at the end of the filename.
5. **Extension Parser Tricks**: Trick the parser with techniques like doubling extensions or adding junk data (e.g., `file.php%00.png`).
6. **NTFS Alternate Data Streams**: Use NTFS ADS in Windows to create files with forbidden extensions (e.g., `file.asp:.jpg`).

### Bypassing Content-Type and Magic Number Checks

To ensure that only files with appropriate content types and magic numbers are uploaded, preventing the execution of malicious files disguised as legitimate ones.

**Example Vulnerable Code**:

```php
if ($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES['file'])) {
    $fileType = mime_content_type($_FILES['file']['tmp_name']);
    $file = fopen($_FILES['file']['tmp_name'], 'rb');
    $header = fread($file, 4); // Read the first 4 bytes for magic number
    fclose($file);

    if ($fileType !== 'image/png' || $header !== "\x89PNG") {
        die('Invalid file type');
    }
    move_uploaded_file($_FILES['file']['tmp_name'], "uploads/" . $_FILES['file']['name']);
}
```

The content-type header and magic number verification are meant to ensure that the uploaded files are of the expected type (e.g., images) and not disguised as such to execute harmful code. These checks, however, can be easily bypassed by attackers who manipulate these values.

**How to Bypass** it:

1. **Content-Type Header**: Manipulate the HTTP header to indicate a safe MIME type like `image/png` or `application/octet-stream`, regardless of the actual content.
2. **Magic Number**: Embed valid magic number bytes (e.g., `\x89PNG` for PNG files) at the beginning of a malicious file to trick the server into accepting it.
3. **Embedding Payloads**: Hide malicious payloads within the metadata of a legitimate file or utilize chunks like the PLTE chunk in PNG files to compress and conceal the payload.

### Bypassing File Size and Name Restrictions

To prevent the uploading of excessively large files or files with potentially harmful names that could exploit system vulnerabilities.

**Example Vulnerable Code**:

```php
$maxSize = 500000; // 500 KB size limit
$filename = substr($_FILES['file']['name'], 0, 255); // Limit filename length

if ($_FILES['file']['size'] > $maxSize) {
    die('File is too large');
}

if (preg_match('/\.php$/', $filename)) {
    die('PHP files are not allowed');
}

move_uploaded_file($_FILES['file']['tmp_name'], "uploads/" . $filename);
```

File size and name restrictions are designed to prevent resource exhaustion attacks (by uploading overly large files) and avoid executing files with dangerous extensions. However, attackers can exploit these checks using various techniques.

**How to Bypass** it:

1. **Filename Length**: Take advantage of filename length limitations by creating names that exceed the limit, potentially causing the server to truncate the extension (e.g., `file.php.jpg` truncated to `file.php`).
2. **Reserved Names**: Use special or reserved names on systems like Windows (`CON`, `PRN`) to create unexpected behavior, potentially bypassing checks or triggering vulnerabilities.

### Special Techniques

To protect against advanced attack methods that involve sophisticated file manipulations or the exploitation of specific software vulnerabilities.

**Example Vulnerable Code**:

```php
if ($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES['file'])) {
    $filename = $_FILES['file']['name'];

    if (pathinfo($filename, PATHINFO_EXTENSION) === 'zip') {
        $zip = new ZipArchive;
        if ($zip->open($_FILES['file']['tmp_name']) === TRUE) {
            $zip->extractTo('/var/www/uploads/');
            $zip->close();
            echo 'Zip file extracted successfully';
        } else {
            die('Failed to open the zip file');
        }
    } else {
        die('Only zip files are allowed');
    }
}
```

Handling compressed files like ZIP or TAR files requires care, as attackers can manipulate these files to include symlinks, directory traversal paths, or malicious code. These files can be used to compromise the server once extracted.

**How to Bypass** it:

1. **Polyglot Files**: Create files that can be interpreted as multiple types (e.g., both a GIF and a JAR file), allowing them to bypass checks while executing code.
2. **Zip/Tar File Tricks**: Embed symlinks or use directory traversal techniques within compressed files to extract files into sensitive directories or with dangerous names (e.g., `../../../var/www/html/shell.php`).
3. **ImageTragic**: Exploit vulnerabilities in image processing libraries like ImageMagick by uploading specially crafted images that trigger arbitrary command execution on the server.

### Other Techniques

To safeguard against a range of additional attacks that involve manipulating file paths, executing arbitrary commands, or exploiting service workers.

**Example Vulnerable Code**:

```php
if (isset($_GET['file'])) {
    $filePath = "uploads/" . $_GET['file'];

    if (strpos($filePath, '..') !== false) {
        die('Directory traversal detected');
    }

    if (file_exists($filePath)) {
        include($filePath);
    } else {
        die('File not found');
    }
}
```

The inclusion of user-specified files or traversal paths without proper validation can lead to the execution of unauthorized files or even system commands. This poses a significant security risk if exploited.

**How to Bypass** it:

1. **Local File Inclusion**: Exploit the inclusion mechanism to execute files previously uploaded, potentially gaining control over the server.
2. **Path Traversal**: Manipulate the file path to traverse directories and access sensitive files (e.g., `../../../etc/passwd`).
3. **Service Workers Exploitation**: Upload JavaScript files that can be registered as service workers and combined with XSS vulnerabilities to persist control over a web application.
4. **Remote Command Execution**: Leverage server misconfigurations to execute commands directly on the server, leading to a full compromise.

### Mitigation Techniques

To effectively mitigate the risks associated with file upload bypass vulnerabilities, several key measures should be implemented.

First, utilize robust scanning tools to thoroughly examine uploaded files for malicious content, such as embedded scripts or executable code. Enforce strict file size limitations to prevent large uploads that could strain server resources or conceal harmful data. Store uploaded files outside of the webroot directory to eliminate the risk of direct access via URLs, ensuring that files cannot be executed directly from the web server.

Additionally, rename uploaded files using a secure, randomized naming convention to prevent the execution of files with dangerous extensions and to avoid accidental overwriting of existing files. Implement deep content inspection techniques that go beyond simple file type verification to detect and block files containing hidden malicious code.

Finally, ensure that strict access controls are in place for all directories handling uploads, allowing only authorized users or processes to interact with these files.

### Detection Techniques

To detect and respond to file upload bypass attempts, it is crucial to monitor the file system for any unauthorized or unexpected changes, particularly in directories designated for file uploads.

Regularly analyze server logs for unusual activities related to file uploads, such as multiple failed attempts or the upload of files with suspicious names or extensions. Employ automated log analysis tools to identify and alert on patterns indicative of potential exploitation attempts.

Integrate intrusion detection systems (IDS) to monitor for abnormal behavior and malicious activity associated with file uploads, and configure these systems with rules tailored to identify common attack signatures.

Deploy a web application firewall (WAF) to actively filter out malicious upload attempts; keep WAF rules consistently updated to protect against emerging threats. Additionally, implement user behavior analytics to detect anomalies in file upload activities that may suggest an attempt to bypass security measures.

Utilize machine learning models to enhance the accuracy of detection, allowing the system to adapt to new attack vectors and patterns over time.

## Resource

- [OWASP File Upload Vulnerabilities](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)
- [Pentest Everything File Upload](https://viperone.gitbook.io/pentest-everything/everything/everything-web/file-upload)
