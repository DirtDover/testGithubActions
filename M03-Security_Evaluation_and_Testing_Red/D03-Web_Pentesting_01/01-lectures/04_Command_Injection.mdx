# Command Injection

## What you will learn in this course üßêüßê

- Understand the concept of Command Injection
- Learn how to exploit Command Injection vulnerabilities

## Description

Command Injection occurs when an attacker can execute arbitrary commands on the host operating system through a vulnerable application. This typically happens due to improper handling of user input within system command functions. For exemple, in the case of an actual attack, it would proceed as follows:

1. The application takes user input and passes it to a system shell.

2. The attacker crafts input to execute additional commands.

3. The system shell executes the malicious commands, allowing the attacker to control the server.

![Command_Injection](https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D04-Web_Pentesting_01/01-lectures/Command_Injection.png)

## Exploitation

An attack happens when attackers manage to insert harmful commands into form fields or other user inputs on a web application. If developers don‚Äôt properly filter and validate these inputs, the attacker can exploit this weakness to run commands on the server‚Äôs operating system. Here‚Äôs an example of a system command injection:

Imagine a website has a form that lets users check if another website is online by entering its URL. The server-side code uses the `exec()` function to run a system command that checks the website‚Äôs status by sending an HTTP request to the provided URL. Here‚Äôs a sample code:

```php
<?php
if(isset($_POST['submit'])){
¬† ¬† $url = $_POST['url'];
¬† ¬† $command = "curl -I " . $url;
¬† ¬† exec($command, $output, $result);
¬† ¬† if ($result == 0 && strpos($output[0], '200 OK') !== false) {
¬† ¬† ¬† ¬† echo "The website is online.";
¬† ¬† } else {
¬† ¬† ¬† ¬† echo "The website is offline.";
¬† ¬† }
}
?>
```

In this case, if an attacker enters a harmful command in the URL field, they can make the server run commands on it. For example, if they type this into the form field:

`example.com; rm -rf /`

The server would run `curl -I example.com; rm -rf /`, which sends an HTTP request to `example.com` and then deletes all files on the server, causing serious damage.

Attackers often use basic techniques like chaining commands with `;`, `&&`, or `||`, using pipes `|` and redirections `>`, or executing commands in subshells with backticks or `$()`. They may also bypass input restrictions by breaking out of quoted strings, manipulating environment variables, or using more advanced methods like time-based or DNS-based data exfiltration. To get around security filters, they might use special techniques for Windows or Linux, and they could deploy payloads like reverse shells or file manipulations to take over the server.

Here are also other different techniques of command injection possible :

### SQL Injection

#### Vulnerable Code

```python
# Python with SQLite
import sqlite3

def login(username, password):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    cursor.execute(query)
    return cursor.fetchone()
```

#### Exploitation

#### Legitimate Use Case:

In a legitimate context, dynamic SQL queries might be necessary for complex search functionalities where users need to filter results based on various criteria. However, these queries should be properly parameterized to prevent injection.

- **Command line (payload):**

```sql
' OR '1'='1
```

- **Explanation:**

This payload manipulates the SQL query to always return true, bypassing authentication and granting unauthorized access.

### Cross-Site Scripting (XSS)

#### Vulnerable Code

```html
<!-- Example in HTML -->
<form method="POST" action="/submit">
    <input type="text" name="comment">
    <input type="submit" value="Submit">
</form>

<!-- Displaying the comment -->
<div>
    Comment: <?php echo $_POST['comment']; ?>
</div>
```

#### Exploitation

- **Command line (payload):**

```html
<script>alert('XSS')</script>
```

- **Explanation:**

This code injects a JavaScript script into the page, potentially allowing malicious actions such as cookie theft or redirection to phishing sites.

#### Legitimate Use Case:

XSS vulnerabilities typically arise in web applications that allow user-generated content, like comments or reviews. Developers often want to display user inputs, but they must sanitize these inputs to prevent malicious scripts from being executed.

### Local File Inclusion (LFI)

#### Legitimate Use Case:

LFI is often used in applications that dynamically include different content or pages based on user input, such as CMS platforms. However, the input must be properly sanitized to prevent access to unintended files.

#### Vulnerable Code

```php
<?php
if (isset($_GET['page'])) {
    include($_GET['page']);
} else {
    include('default.php');
}
?>
```

#### Exploitation

- **Command line (payload):**

```bash
curl "http://example.com/index.php?page=../../../../etc/passwd"
```

- **Explanation:**

This command attempts to include a sensitive system file (`/etc/passwd`), potentially exposing confidential information.

### Cross-Site Request Forgery (CSRF)

#### Legitimate Use Case:

Forms like this are commonly used in online banking or payment systems to perform transactions. In a legitimate scenario, CSRF tokens should be implemented to verify the request's authenticity.

#### Vulnerable Code

```html
<form action="http://example.com/transfer" method="POST">
    <input type="hidden" name="amount" value="1000">
    <input type="hidden" name="to_account" value="987654321">
    <input type="submit" value="Transfer">
</form>
```

#### Exploitation

- **Command line (exploit):**

```html
<img src="http://example.com/transfer?amount=1000&to_account=987654321" style="display:none;">
```

- **Explanation:**

The attack forces a logged-in user to perform an action (like a money transfer) without their consent, exploiting their active session.

### Directory Traversal

#### Legitimate Use Case:

Directory traversal might be legitimately used in applications that need to include or serve different files based on user input, such as image galleries or document management systems. Proper input validation should be implemented to prevent accessing unintended files.

#### Vulnerable Code

```php
<?php
$file = $_GET['file'];
include("/var/www/html/" . $file);
?>
```

#### Exploitation

- **Command line (payload):**

```bash
curl "http://example.com/index.php?file=../../../../etc/passwd"
```

- **Explanation:**

This exploit attempts to access files outside the intended directory, such as sensitive system files (`/etc/passwd`).

## Mitigation Techniques

To mitigate command injection vulnerabilities, prioritize avoiding direct execution of system commands from your web application. Instead, opt for safer, higher-level abstractions provided by programming languages, such as APIs or libraries designed for specific tasks like file handling, database interactions, or network communications. For example, use file management libraries rather than system commands to handle file operations, or employ built-in database functions for queries and updates instead of constructing shell commands.

If executing system commands is necessary, adopt secure practices to minimize risk. One effective strategy is to use job schedulers or background task managers that run predefined, secure scripts rather than dynamic commands based on user input. This approach reduces the opportunity for user input to influence command execution directly.

Ensure any system commands are executed in a controlled manner by validating and sanitizing all inputs rigorously. This includes escaping or filtering potentially dangerous characters, such as `;`, `&`, `|`, and `&&`. Implement strict input validation rules and consider using parameterized commands when possible.

Furthermore, apply the principle of least privilege by running your application with the minimum permissions necessary. This limits the potential damage if an injection attack occurs. Regularly review and update your security practices to address new threats and ensure robust protection against command injection vulnerabilities.

## Detection Techniques

For detecting command injection vulnerabilities, review the application code for any instances where user input is passed to system command functions. Conduct regular security audits and penetration testing to identify potential vulnerabilities. Monitor server logs for unusual or unexpected command executions, and set up alerts for patterns indicative of command injection attempts. Use automated security scanning tools to identify common command injection vectors and misconfigurations. Additionally, implement runtime application self-protection (RASP) to detect and block command injection attacks in real-time.

## Resource

- [OWASP Command Injection](https://owasp.org/www-community/attacks/Command_Injection)
- [OS Command Injection](https://knowledge-base.secureflag.com/vulnerabilities/code_injection/os_command_injection_vulnerability.html)
