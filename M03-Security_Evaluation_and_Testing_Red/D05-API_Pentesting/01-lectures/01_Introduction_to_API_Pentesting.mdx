# Introduction to API Pentesting

## What you will learn in this course üßêüßê

- Understand the different types of APIs and their functionalities
- Learn about the methodology for API pentesting
- Explore common API vulnerabilities and exploitation techniques

APIs, or Application Programming Interfaces, serve as intermediaries that enable different software applications to communicate and interact with each other. They define a set of rules and protocols that facilitate data exchange and functionality execution between disparate systems without requiring knowledge of each other's internal workings.

## Types of APIs

**REST API:** REST (Representational State Transfer) APIs adhere to principles for designing networked applications. They utilize HTTP methods such as GET, POST, PUT, and DELETE to interact with resources identified by URLs. REST APIs are lightweight, easy to use, and widely adopted for web services due to their simplicity and scalability.

**GraphQL:** GraphQL is both a query language and a runtime for executing queries against APIs. It allows clients to specify the exact data they need, reducing over-fetching of data and enhancing network efficiency. GraphQL APIs provide flexibility in data retrieval compared to REST, enabling precise data querying and retrieval.

**SOAP/XML:** SOAP (Simple Object Access Protocol) facilitates structured information exchange in web services. It uses XML to format messages and relies on protocols like HTTP and SMTP for transmission. SOAP APIs are known for their robustness and built-in security features, making them suitable for complex enterprise applications.

### How APIs Operate

#### Example with REST API:

1. **Client Request:** A client application sends a GET request to a REST API endpoint URL, such as `https://api.example.com/customers/123`.
2. **Server Processing:** The REST server receives the GET request, parses the endpoint URL to identify the resource (`customers`), and retrieves the data associated with the customer ID `123` from the database.
3. **Server Response:** The REST server sends a response back to the client in JSON format, containing the details of the customer with ID `123`, such as:

```json
{
 "id": 123,
 "name": "John Doe",
 "email": "john.doe@example.com",
 "phone": "+1234567890",
 "address": {
   "street": "123 Main St",
   "city": "Anytown",
   "state": "CA",
   "zip": "12345"
 }
}
```

#### Example with GraphQL API:

1. **Client Request:** A client application sends a GraphQL query request to a GraphQL endpoint URL, specifying the exact fields and data it needs, such as:

```graphql
query {
 customer(id: 123) {
   name
   email
   address {
	 city
	 state
   }
 }
}
```

2. **Server Processing:** The GraphQL server processes the query, executes it by fetching the requested data from the database, and resolves the fields specified in the query.
3. **Server Response:** The GraphQL server sends a response back to the client, returning JSON data structured exactly as requested:

```json
{
 "data": {
   "customer": {
	 "name": "John Doe",
	 "email": "john.doe@example.com",
	 "address": {
	   "city": "Anytown",
	   "state": "CA"
	 }
   }
 }
}
```

### Example with SOAP/XML API:

1. **Client Request:** A client application sends a SOAP request message to a web service endpoint URL, such as `https://api.example.com/CustomerService`, specifying the operation to be performed and the necessary parameters in XML format. For example, the client might want to retrieve information about a customer with ID `123`. The request message could look like this:

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cus="http://example.com/customer">
   <soapenv:Header/>
   <soapenv:Body>
	  <cus:GetCustomerDetailsRequest>
		 <cus:CustomerId>123</cus:CustomerId>
	  </cus:GetCustomerDetailsRequest>
   </soapenv:Body>
</soapenv:Envelope>
```

2. **Server Processing:** The SOAP server receives the XML request, parses the XML to extract the operation (`GetCustomerDetailsRequest`) and the parameters (`CustomerId`), and processes the request by retrieving the data associated with the customer ID `123` from the database.

3. **Server Response:** After processing, the SOAP server sends a SOAP response message back to the client, formatted in XML. The response contains the requested customer data. The response message might look like this:

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:cus="http://example.com/customer">
   <soapenv:Header/>
   <soapenv:Body>
	  <cus:GetCustomerDetailsResponse>
		 <cus:Customer>
			<cus:Id>123</cus:Id>
			<cus:Name>John Doe</cus:Name>
			<cus:Email>john.doe@example.com</cus:Email>
			<cus:Phone>+1234567890</cus:Phone>
			<cus:Address>
			   <cus:Street>123 Main St</cus:Street>
			   <cus:City>Anytown</cus:City>
			   <cus:State>CA</cus:State>
			   <cus:Zip>12345</cus:Zip>
			</cus:Address>
		 </cus:Customer>
	  </cus:GetCustomerDetailsResponse>
   </soapenv:Body>
</soapenv:Envelope>
```

## Methodology

Attacking APIs requires a systematic approach to identify vulnerabilities and exploit them effectively. Here's a detailed methodology to follow when assessing API security:

### Information Gathering

#### API Documentation Review

Understanding the API's functionality, endpoints, parameters, and expected responses is crucial. For example, in an e-commerce API, reviewing documentation reveals endpoints for user authentication, product listings, and order processing. This insight helps in identifying potential vulnerabilities such as unprotected endpoints or insufficient input validation.

**Example**: To review API documentation, you can use a tool like Swagger UI to visualize the API endpoints and their details. Here's how you might use Python to fetch and review the documentation from a Swagger endpoint.

```python
import requests

# URL of the Swagger API documentation
swagger_url = "https://api.example.com/swagger.json"

# Fetch the documentation
response = requests.get(swagger_url)
swagger_data = response.json()

# Display endpoints and their details
for path, methods in swagger_data['paths'].items():
    print(f"Endpoint: {path}")
    for method, details in methods.items():
        print(f"  Method: {method.upper()}")
        print(f"    Description: {details.get('description', 'No description')}")
        print(f"    Parameters: {details.get('parameters', 'No parameters')}")
```

#### Endpoint Discovery

Identifying and enumerating all available endpoints is essential. For instance, using tools like Swagger UI or Postman to map out API endpoints can reveal hidden or unlinked endpoints that may lack proper security controls. Additionally, tools like FFUF (Fuzz Faster U Fool) or WFUZZ can be used to automate the process of discovering hidden endpoints. By performing a directory and file brute force scan, these tools can help uncover endpoints that are not documented or are otherwise obscured, potentially exposing weaknesses that could be exploited.

**Example**: Using Python with `requests` to test potential endpoints:

```python
import requests

# Base URL of the API
base_url = "https://api.example.com/"

# List of potential paths to test
paths = ["admin", "backup", "test"]

# Test the paths
for path in paths:
    url = f"{base_url}{path}"
    response = requests.get(url)
    if response.status_code == 200:
        print(f"Found endpoint: {url}")
    else:
        print(f"Endpoint not found: {url}")
```

#### Enumerate Methods and Parameters

Testing different HTTP methods (GET, POST, PUT, DELETE) and injecting various parameters helps uncover injection points and vulnerabilities. For example, testing a POST method with manipulated parameters to identify SQL injection vulnerabilities in an API endpoint.

**Example**: Using Python to test various methods and payloads:

```python
import requests

# Endpoint to test
endpoint = "https://api.example.com/resource"

# HTTP methods to test
methods = ["GET", "POST", "PUT", "DELETE"]

# Payloads to inject
payloads = [{"param": "value"}, {"param": "value' OR '1'='1"}, {"param": "<script>alert('XSS')</script>"}]

# Test methods and payloads
for method in methods:
    for payload in payloads:
        response = requests.request(method, endpoint, data=payload)
        print(f"Method: {method}, Payload: {payload}, Status Code: {response.status_code}")
        if response.status_code == 200:
            print(f"Response: {response.text}")
```

### Threat Modeling and Risk Assessment

#### Identify Sensitive Data and Functions

Pinpointing endpoints that handle sensitive data (e.g., user credentials, payment information) is critical. For instance, analyzing API responses to detect where sensitive information is transmitted or stored can reveal potential risks such as data exposure or unauthorized access.

**Example**: Using Python to check for sensitive data in API responses:

```python
import requests

# Potentially sensitive endpoint
sensitive_endpoint = "https://api.example.com/user/profile"

# Send the request
response = requests.get(sensitive_endpoint)

# Analyze the response
if "password" in response.text or "credit_card" in response.text:
    print("Sensitive data found in response:")
    print(response.text)
else:
    print("No sensitive data found.")
```

#### Assess Authentication and Authorization Mechanisms

Evaluating the effectiveness of authentication and authorization processes is key. Testing for weak credentials or flaws in session management can uncover vulnerabilities that may lead to unauthorized access or privilege escalation.

**Example**: Using Python to test various access tokens:

```python
import requests

# URL of the protected endpoint
protected_endpoint = "https://api.example.com/admin"

# Access tokens to test
tokens = ["valid_token", "expired_token", "invalid_token"]

# Test the tokens
for token in tokens:
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get(protected_endpoint, headers=headers)
    if response.status_code == 200:
        print(f"Access granted with token: {token}")
    elif response.status_code == 401:
        print(f"Unauthorized access with token: {token}")
    else:
        print(f"Unexpected status code with token: {token}, Status Code: {response.status_code}")
```

### Testing for Common Vulnerabilities

Many vulnerabilities can exist in APIs. It is crucial to understand these vulnerabilities to detect, exploit, and remediate them effectively.

Here are the **OWASP Top 10 API** vulnerabilities:

- **Broken Object Level Authorization**
- **Broken Authentication**
- **Broken Object Property Level Authorization**
- **Unrestricted Resource Consumption**
- **Broken Function Level Authorization**
- **Unrestricted Access to Sensitive Business Flows**
- **Server Side Request Forgery (API version)**
- **Security Misconfiguration**
- **Improper Inventory Management**
- **Unsafe Consumption of APIs**

In the upcoming sessions, we will explore each of these vulnerabilities in detail, discussing how attackers exploit them and best practices for mitigation.

## Exploitation

### API Discovery and Enumeration

API Discovery and Enumeration are foundational steps in exploiting an API, where attackers seek to identify all available endpoints, including those not intended for public use. This process can uncover hidden or undocumented paths, which may lack security measures, providing attackers with potential entry points. Tools like Swagger UI, Postman, FFUF, and WFUZZ are commonly used for this purpose.

Attackers might use a tool like FFUF to automate the process of testing different endpoint names against the base URL of an API. For instance, an attacker could use a wordlist of common endpoint names to brute-force potential paths.

**Concrete Example:**

```bash
ffuf -w common-api-endpoints.txt -u https://example.com/api/v1/FUZZ
```

In this example, `FFUF` will try all entries in `common-api-endpoints.txt` against the base URL, revealing endpoints like `/api/v1/admin` or `/api/v1/debug`, which might not be secured properly.

### Authentication and Authorization Flaws

Authentication and Authorization Flaws are critical issues where the mechanisms for verifying user identity or permissions are inadequately implemented. These flaws can lead to unauthorized access if attackers bypass authentication checks or manipulate authorization logic.

A common exploitation method involves manipulating JSON Web Tokens (JWTs) to gain unauthorized access. For example, if an API accepts unsigned or poorly signed JWTs, an attacker could forge a token with elevated privileges.

**Vulnerable Code Example:**

```javascript
// Vulnerable token validation logic
if (req.headers['x-access-token']) {
    // Assume token is valid without verifying its signature or expiration
    next();
} else {
    res.status(401).send('Unauthorized');
}
```

This code snippet only checks for the presence of a token but does not validate its integrity or authenticity, allowing attackers to use forged or expired tokens to access protected resources.

### Input Validation and Injection Attacks

Input Validation and Injection Attacks occur when APIs do not properly sanitize user inputs, allowing attackers to inject malicious code or commands. This is particularly dangerous when APIs interact with databases, as it can lead to SQL or NoSQL injection attacks, compromising data integrity and confidentiality.

Attackers inject malicious input through API parameters, directly targeting the backend systems. A classic example is SQL injection, where an attacker might manipulate an input field to execute unintended SQL commands.

**Concrete Example of Vulnerable Code:**

```python
user_input = request.args.get('user')
query = f"SELECT * FROM users WHERE username = '{user_input}'"
```

### Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) involves attackers injecting malicious scripts into API data, which are then executed in a user‚Äôs browser. This can lead to data theft, session hijacking, or other malicious actions performed on behalf of the user.

In stored XSS, attackers inject scripts into data stored by the API, such as comments or messages. In reflected XSS, scripts are injected into the API response and executed immediately upon receipt by the client.

**Concrete Example of Vulnerable Code:**

```javascript
app.get('/comments', (req, res) => {
    res.send(`<div>${req.query.comment}</div>`);
});
```

If an attacker submits a comment like `<script>alert('XSS')</script>`, this script would execute in the browser of anyone viewing the comment, demonstrating the risks of unsanitized input.

### Mass Assignment and Data Exposure

Mass Assignment and Data Exposure vulnerabilities occur when APIs allow user inputs to be bound directly to internal objects without proper filtering. This can lead to unauthorized changes to sensitive fields and unintended exposure of sensitive information.

Attackers can manipulate JSON payloads to include fields that should not be user-controllable. For instance, an attacker could attempt to change their user role by including an unauthorized field in the payload.

**Vulnerable Code Example:**

```javascript
// Example where user input is directly mapped to a user object
app.post('/updateProfile', (req, res) => {
    const user = getUser(req.userId);
    Object.assign(user, req.body); // All properties from req.body are assigned to user
    user.save();
});
```

If an attacker sends a payload like `{"role": "admin"}`, they could escalate their privileges without any validation checks.

### Rate Limiting and Denial of Service (DoS)

Rate Limiting and Denial of Service (DoS) vulnerabilities arise when APIs lack mechanisms to limit the number of requests a user can make in a given time frame. Without rate limiting, attackers can flood the API with requests, causing service disruption or even complete outages.

Attackers can use automated scripts or tools like Apache JMeter to send a high volume of requests to an API, overwhelming the server‚Äôs capacity. Advanced attackers may bypass simple IP-based rate limits by using multiple IP addresses or API keys.

**Concrete Example of a Vulnerable Scenario:**
An API endpoint like `/api/v1/resource` processes complex calculations but lacks rate limiting. An attacker could script a flood of requests to this endpoint, consuming all available server resources and rendering the service unavailable to legitimate users.

### Business Logic Attacks

Business Logic Attacks exploit flaws in the way an API processes logical operations. These are not traditional vulnerabilities but arise from the incorrect implementation of business rules, allowing attackers to manipulate application functionality for unintended outcomes.

Attackers look for logical inconsistencies, such as the ability to bypass steps in a transaction process. For example, if the API does not properly validate the sequence of operations during a checkout process, attackers might skip payment steps, resulting in unauthorized access to goods or services.

**Concrete Example of Vulnerable Code:**

```javascript
app.post('/applyDiscount', (req, res) => {
    const discountCode = req.body.code;
    const discount = getDiscount(discountCode);
    cart.applyDiscount(discount);
    res.send(cart.total);
});
```

If there is no check to ensure that a discount code is only applied once per customer or per order, attackers could repeatedly apply the same code to reduce the price to zero.

### Security Misconfigurations

Security Misconfigurations occur when APIs are deployed with insecure default settings or lack proper security hardening. Common issues include permissive CORS policies, default credentials, and unnecessary services or endpoints being exposed.

Attackers exploit these weaknesses by interacting with the API in ways that bypass normal restrictions. A common issue is overly permissive CORS settings, which can allow cross-origin requests from untrusted sources, enabling unauthorized actions.

**Vulnerable Configuration Example:**

```javascript
app.use(cors({ origin: '*' }));  // Permissive CORS configuration
```

This configuration allows any website to interact with the API, making it susceptible to cross-site request forgery (CSRF) attacks where attackers can make unauthorized requests on behalf of legitimate users.

### Tools and Techniques

Throughout the exploitation process, using the right tools and techniques is crucial for identifying and exploiting vulnerabilities. Each tool has its unique capabilities, making it valuable for specific tasks during security assessments. Tools like Burp Suite and OWASP ZAP are highly effective for intercepting, modifying, and replaying API requests, allowing testers to probe for weaknesses such as injection points, cross-site scripting (XSS), and authentication flaws. Postman is excellent for manual API interaction and testing, providing a user-friendly interface to craft API requests, set specific headers, and thoroughly examine API responses for potential vulnerabilities.

**[Burp Suite](https://portswigger.net/burp)** is particularly useful for intercepting requests to an API, modifying parameters, and analyzing responses. This makes it an ideal choice for discovering injection points, XSS, and authentication flaws. Its powerful features, such as repeater and intruder, facilitate the testing of various inputs and payloads, allowing for comprehensive security testing.

**[OWASP ZAP](https://www.zaproxy.org/)** automates the detection of common security issues, such as XSS and SQL injection, through its active and passive scanning features. It also helps map out all API endpoints using spidering, which can be used to discover hidden paths and resources that might not be documented. This makes it a versatile tool for both beginners and experienced security professionals.

**[Postman](https://www.postman.com/)** is widely used for crafting detailed API requests, enabling testers to set specific headers, body parameters, and authentication tokens. Its environment management and scripting capabilities allow for complex testing scenarios, making it an essential tool for both development and security testing. Postman‚Äôs ease of use helps testers manually interact with APIs, ensuring they can explore various functionalities and potential security issues.

**[WFUZZ](https://github.com/xmendez/wfuzz)** is invaluable for brute-forcing and fuzzing. It automates the process of discovering hidden endpoints and parameters by injecting different inputs into API requests. By leveraging wordlists, WFUZZ can help uncover endpoints that are not documented but still accessible, exposing potential security gaps. It's particularly useful for parameter discovery, helping find hidden parameters that could be used for attacks.

**[FFUF](https://github.com/ffuf/ffuf)** (Fuzz Faster U Fool) is another powerful tool for discovering hidden files, directories, and parameters within APIs. It is known for its speed and efficiency, making it suitable for testing large applications quickly. FFUF can also be used for parameter fuzzing and testing for response anomalies, helping identify endpoints that might behave differently under certain conditions, which could indicate vulnerabilities.

**[JWT.io](https://jwt.io/)** is critical for inspecting and manipulating JSON Web Tokens. JWTs are commonly used for authentication in APIs, and improper handling can lead to severe security issues. JWT.io allows security testers to decode, verify, and modify JWTs, making it easier to uncover flaws in token handling, such as weak signing algorithms, missing signatures, or improper claims. By using JWT.io, testers can identify vulnerabilities in token validation mechanisms, which could be exploited to bypass authentication or authorization controls.

## Resources:

- [Amazon What are APIs ?](https://aws.amazon.com/fr/what-is/api/)
- [Hack&Trick Web API Pentesting](https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/web-api-pentesting)
- [SOAP vs REST vs GRAPHQL](https://www.geeksforgeeks.org/rest-api-vs-graphql-vs-soap/)
- [OWASP TOP 10 API](https://owasp.org/API-Security/editions/2023/en/0x11-t10/)