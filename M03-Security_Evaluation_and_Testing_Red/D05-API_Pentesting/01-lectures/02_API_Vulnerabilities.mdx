# API Vulnerabilities

## What you will learn in this course üßêüßê

- Let's boil down the most common API vulnerabilities!

## Broken Object Level Authorization (BOLA)

Broken Object Level Authorization (BOLA) is a critical security vulnerability that occurs when an API endpoint exposes data objects without correctly enforcing user permissions. This flaw allows unauthorized users to access or manipulate data that they should not be able to view or alter.

![[BOLA.png]]

To illustrate this with a practical example, consider an e-commerce application where users can view their order details through a specific URL. If the application does not correctly validate user permissions for accessing orders, a user could simply change the order ID in the URL to access another user's order details. For instance, changing `https://api.example.com/orders/12345` to `https://api.example.com/orders/12346` might allow them to see someone else's order information. Such a vulnerability can lead to serious data breaches and unauthorized modifications of sensitive information.

**Vulnerable Code Example**

Let‚Äôs take a closer look at how a typical BOLA vulnerability might manifest in code. Consider the following Python snippet using the Flask web framework:

```python
# Flask endpoint for viewing orders
@app.route('/orders/<int:order_id>', methods=['GET'])
def get_order(order_id):
    order = Order.query.get(order_id)
    return jsonify(order.to_dict())
```

In this example, the `get_order` function fetches an order by its ID from the database and returns the order details as a JSON object. The problem with this code is that it does not check whether the requesting user is authorized to view the order with the specified ID. As a result, if an unauthorized user can guess or manipulate the order ID, they could access orders that do not belong to them.

**Exploiting the Vulnerability**

To exploit this vulnerability, an attacker could start by making an initial request to access their order:

```
GET https://api.example.com/orders/12345
```

If the server responds with the order details, the attacker might then try modifying the request to access a different order:

```
GET https://api.example.com/orders/12346
```

Without proper access controls, the server might return another user‚Äôs order details. This simple manipulation demonstrates how easily sensitive data can be exposed due to inadequate authorization checks.

#### Detecting and Mitigating BOLA Vulnerabilities

Detecting BOLA vulnerabilities often involves performing thorough access control tests. Security teams can use automated tools to scan APIs for endpoints that do not properly enforce authorization. Additionally, regularly reviewing access logs for unusual access patterns can help identify unauthorized access attempts.

To mitigate these vulnerabilities, developers should implement strict access controls and enforce server-side authorization checks for every API request. Using Role-Based Access Control (RBAC) can ensure that users only access the data and perform the actions they are authorized to. Each API endpoint should verify not just the existence of the resource being requested, but also whether the user making the request has the necessary permissions to access that resource.

#### Real-World Example: BOLA Attack at the Central Bank of Russia

In 2016, a BOLA attack targeted [Russia‚Äôs central bank](https://money.cnn.com/2016/12/02/technology/russia-central-bank-hack/), resulting in substantial financial losses amounting to around 2 billion rubles. Attackers exploited vulnerabilities in the bank‚Äôs Fast Payments System to manipulate account IDs, facilitating unauthorized transfers between accounts.

The attackers began by exploiting a BOLA vulnerability to obtain customer account data. They then used the bank‚Äôs mobile application in debug mode to impersonate legitimate clients. By modifying the account ID associated with each transaction, the attackers redirected funds to accounts under their control, bypassing the bank's usual verification processes. This real-world example underscores the critical importance of robust authorization mechanisms to protect against such exploits.

## Broken Authentication

Broken authentication occurs when there are flaws in the API authentication mechanisms, which can allow attackers to compromise user accounts or bypass authentication altogether. This type of vulnerability is often the result of weak password policies, insufficient account lockout mechanisms, or improper handling of authentication tokens. For example, APIs that do not enforce strong password requirements are susceptible to brute-force attacks, where attackers use automated tools to try a large number of password combinations in hopes of gaining unauthorized access.

![[BA.png]]

**Vulnerable Code Example**

Consider the following code snippet, which represents a vulnerable login endpoint using the Flask framework:

```python
# Flask endpoint for login
@app.route('/login', methods=['POST'])
def login():
    username = request.json.get('username')
    password = request.json.get('password')
    user = User.query.filter_by(username=username).first()
    if user and user.check_password(password):
        token = generate_token(user)
        return jsonify({"token": token})
    return jsonify({"error": "Invalid credentials"}), 401
```

In this example, the login endpoint accepts a username and password, checks them against the stored credentials, and generates an authentication token if the credentials are valid. However, the code does not implement any form of protection against repeated login attempts. An attacker could exploit this by running a script that repeatedly attempts to log in with different password combinations, potentially compromising user accounts with weak or common passwords.

**Exploiting the Vulnerability**

To exploit this vulnerability, an attacker could use a brute-force attack script. Here's an example of how such a script might look in Python:

```python
import requests

url = "https://api.example.com/login"
usernames = ["admin", "user"]
passwords = ["password123", "123456", "admin"]

for username in usernames:
    for password in passwords:
        response = requests.post(url, json={"username": username, "password": password})
        print(f"Trying {username}:{password} - Status Code: {response.status_code}")
```

This script automates the process of sending login requests with different username and password combinations. If the API endpoint has weak password policies or lacks account lockout mechanisms, the attacker could successfully gain access to user accounts by guessing the correct credentials.

#### Detection and Mitigation

Detecting broken authentication vulnerabilities requires regular security assessments, including penetration testing, to identify weak authentication methods. Monitoring for failed login attempts and unusual login patterns can help identify potential brute-force attacks. Implementing strong password policies is crucial for mitigation. Passwords should be required to meet certain complexity criteria, such as a minimum length, use of special characters, and a combination of uppercase and lowercase letters. Additionally, multi-factor authentication (MFA) should be implemented to add an extra layer of security.

Proper session management is also essential to secure authentication tokens. Tokens should be securely stored and should not be easily guessable. Implementing rate limiting on authentication endpoints can help prevent brute-force attacks by limiting the number of login attempts allowed within a certain time frame.

#### Real-World Example: The Parler Data Breach

In 2021, a significant data breach occurred involving the social media platform Parler, highlighting vulnerabilities in its authentication mechanisms. A [comprehensive analysis by Salt Security](https://salt.security/blog/unpacking-the-parler-data-breach?) revealed that Parler had serious flaws that allowed unauthorized access to approximately 70TB of user data. This breach included the exposure of user profile information, message posts, images, and videos.

One of the critical issues identified was the presence of API endpoints that were accessible without any authentication. Some APIs allowed direct access to sensitive user data, bypassing authentication protocols. Additionally, a security misconfiguration involving a Twilio integration was alleged to have been exploited, potentially allowing attackers to bypass multi-factor authentication (MFA) during account creation and extract data. This breach underscored the importance of properly configured authentication mechanisms and the need for vigilant security practices to protect user data from unauthorized access.

## Broken Object Property Level Authorization (BOPLA)

Broken Object Property Level Authorization (BOPLA) is a security vulnerability that arises when APIs fail to enforce proper checks on individual properties of data objects, allowing unauthorized modifications. This issue can lead to unauthorized users altering sensitive information, such as account roles or access levels, by manipulating request payloads. A common scenario involves a user modifying their account type from `standard` to `admin` without proper authorization checks in place, potentially gaining elevated privileges.

![[BOPLA.png]]

**Vulnerable Code Example**

Consider the following example, where a Flask-based API endpoint allows users to update their profiles:

```python
# Flask endpoint for updating user profile
@app.route('/users/<int:user_id>', methods=['PATCH'])
def update_user(user_id):
    user = User.query.get(user_id)
    if user:
        for key, value in request.json.items():
            setattr(user, key, value)
        db.session.commit()
        return jsonify(user.to_dict())
    return jsonify({"error": "User not found"}), 404
```

In this code snippet, the `update_user` function retrieves a user by their ID and updates the user object with the provided data from the request payload. The problem here is that the code does not differentiate between sensitive properties, such as a user‚Äôs role, and regular properties, such as a username or email. As a result, an unauthorized user could modify their account role by simply sending a crafted request that alters their role property.

**Exploiting the Vulnerability**

To exploit this vulnerability, an attacker might send a request to change their user role, elevating their privileges without proper authorization. For instance, the following HTTP request demonstrates how an attacker could attempt to change their role to `admin`:

```http
PATCH /users/12345
Content-Type: application/json

{
   "role": "admin"
}
```

If the API does not perform any authorization checks on the `role` property, this request would successfully change the user‚Äôs role, granting them unauthorized administrative privileges.

#### Detection and Mitigation

Detecting BOPLA vulnerabilities involves reviewing and testing authorization checks on data object properties. Security teams should employ automated tools to scan for endpoints where property-level authorization might be lacking. Additionally, manual code reviews can help identify areas where sensitive properties are not adequately protected.

To mitigate these vulnerabilities, developers must enforce strict property-level authorization. This can be achieved by implementing checks that validate which properties a user is allowed to modify based on their role or permissions. Input validation should be used to ensure that incoming data conforms to expected formats and values, and output encoding should be employed to prevent tampering.

#### Real-World Example: Twitter Users' Data Compromised

A real-world example of a BOPLA vulnerability occurred with Twitter. In August 2022, [Twitter disclosed a vulnerability](https://privacy.twitter.com/en/blog/2022/an-issue-affecting-some-anonymous-accounts) that had been identified earlier in January 2022 through their bug bounty program. This vulnerability allowed individuals to submit email addresses or phone numbers to Twitter‚Äôs systems, revealing information about associated Twitter accounts.

Although Twitter quickly patched the issue upon discovery, there was no initial evidence of exploitation. However, by July 2022, it emerged that a malicious actor had exploited this vulnerability before Twitter implemented the fix, leading to the sale of user data obtained through the exploit.

This incident demonstrates the significant risks posed by BOPLA vulnerabilities, even for large, established companies like Twitter. Despite having extensive security resources, the presence of such vulnerabilities can lead to data breaches and compromise user privacy. It underscores the importance of thorough and continuous security practices, including the enforcement of strict authorization checks at every level of data interaction.

## Unrestricted Resource Consumption

Unrestricted Resource Consumption is a vulnerability that occurs when API endpoints fail to limit the amount of resources a user can consume, allowing attackers to exploit this and cause Denial of Service (DoS) attacks. Such attacks can render a service unavailable by overwhelming it with excessive requests or large payloads, consuming server resources like CPU, memory, or bandwidth. An example would be an attacker sending a large number of requests with oversized payloads to a file upload endpoint, effectively overwhelming the server and causing it to become unresponsive.

![[URC.png]]

### Vulnerable Code Example

Here's an example of a vulnerable Flask API endpoint that handles file uploads:

```python
# Flask endpoint for file uploads
@app.route('/upload', methods=['POST'])
def upload_file():
    file = request.files['file']
    file.save(f"/uploads/{file.filename}")
    return jsonify({"message": "File uploaded successfully"})
```

In this code snippet, the `upload_file` function receives a file from the request and saves it to the server's file system. However, there are no checks on the size or number of files being uploaded, making it susceptible to abuse. An attacker could exploit this by continuously sending large files to the endpoint, consuming all available disk space or overwhelming the server's capacity to handle requests.

### Exploiting the Vulnerability

To exploit this vulnerability, an attacker might use a command like the following to send large payloads repeatedly to the vulnerable endpoint:

```bash
curl -X POST https://api.example.com/upload \
-F 'file=@large_file.dat'
```

By sending excessively large files in rapid succession, the attacker can exhaust server resources, leading to service degradation or complete unavailability.

#### Detection and Mitigation

To detect unrestricted resource consumption vulnerabilities, it is essential to monitor API usage and set up alerts for unusual spikes in resource consumption or request rates. Automated tools can simulate DoS attacks to test the resilience of API endpoints against such exploitation.

Mitigation strategies include implementing rate limiting to control the number of requests a user can make in a given time frame, thus preventing abuse. Throttling can be used to slow down request processing if a user exceeds certain limits. Resource quotas should be established to cap the amount of resources any single user or request can consume. Additionally, proper timeout mechanisms should be implemented to prevent long-running requests from tying up server resources indefinitely.

#### Real-World Example: The DDoS Attack on Poland‚Äôs Tax Portal

A significant real-world example of a distributed denial-of-service (DDoS) attack that exploited API vulnerabilities occurred when [Poland‚Äôs key tax portal](https://www.bloomberg.com/news/articles/2023-03-01/poland-points-finger-at-russia-over-ddos-attack-on-nation-s-key-tax-portal#xj4y7vzkg) was targeted. In this attack, hackers overwhelmed the resources of the APIs supporting Poland's central tax service, rendering the portal inaccessible to citizens for several hours. Given the geopolitical tensions related to the Ukraine conflict, Polish government officials quickly attributed the attack to Russian hackers.

This incident underscores the critical importance of cybersecurity, particularly API security, for both businesses and government institutions. In today's volatile political and social climate, ensuring robust security measures against unrestricted resource consumption is essential to maintain the availability and integrity of essential services.

### Broken Function Level Authorization

Broken Function Level Authorization occurs when APIs expose functionalities without proper authorization checks, allowing unauthorized users to perform actions they should not have access to. This flaw often arises when developers assume certain API endpoints will only be accessed by privileged users or fail to implement robust access control checks. As a result, these endpoints can be exploited by attackers to perform actions like deleting accounts, modifying data, or accessing sensitive information.

![[BFLA.png]]

For instance, consider an API that allows users to delete accounts. If the API does not verify the user's admin status before processing the request, any user could potentially delete any account. This type of vulnerability could be a significant security risk, especially in applications where user data integrity is critical.

**Example Scenario**: A user initiates a DELETE request to `https://api.example.com/users/12345`. Without proper authorization checks, this request successfully deletes another user's account, even though the requester lacks the necessary administrative privileges.

**Vulnerable Code Example**:

```python
# Flask endpoint for deleting users
@app.route('/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    user = User.query.get(user_id)
    if user:
        db.session.delete(user)
        db.session.commit()
        return jsonify({"message": "User deleted successfully"})
    return jsonify({"error": "User not found"}), 404
```

In the above code snippet, the Flask API allows any user to delete an account by sending a DELETE request to the specified endpoint. The code does not check if the requesting user has the authority to delete the account. Thus, anyone who knows a valid `user_id` could delete any user's account.

**Exploit Example**:

A potential exploit of this vulnerability could involve an unauthorized user sending a raw HTTP request as follows:

```http
DELETE /users/67890
```

This request, if processed without proper authorization checks, would delete the user with the ID 67890, regardless of the requester's permissions.

#### Detection and Mitigation:

To detect such vulnerabilities, it's crucial to conduct thorough security testing, focusing on verifying that all API endpoints have adequate authorization checks. Reviewing function-level access controls and ensuring that permission checks are enforced consistently is key to securing these endpoints.

To mitigate this vulnerability, implementing robust function-level authorization checks is essential. Using Role-Based Access Control (RBAC) can help manage access by ensuring that only users with the appropriate role can perform specific actions. Every API endpoint should include authorization mechanisms to validate whether the requester has the necessary permissions to execute the intended action.

#### Real-World Example: New Relic Synthetics

A real-world instance of Broken Function Level Authorization was identified in 2018 by cybersecurity researcher Jon Bottarini, who discovered a vulnerability in New Relic Synthetics. This vulnerability allowed restricted users to alter alerts on Synthetics monitors, a function typically reserved for users with higher privileges.

Bottarini's method of exploiting this vulnerability involved using an intercepting proxy tool, such as Portswigger Burp Suite, to capture traffic from a session with elevated privileges. This traffic included a POST request to an API endpoint responsible for creating alerts. By capturing a similar request from a non-privileged session and retaining the tokens and cookies of the restricted user, Bottarini could modify the captured request to mimic the privileged request. This manipulation allowed him to access and modify functionality that was not supposed to be accessible to restricted users, effectively bypassing the intended authorization checks.

### Unrestricted Access to Sensitive Business Flows

Unrestricted Access to Sensitive Business Flows is a security vulnerability that occurs when APIs expose critical business operations without adequate access controls. This flaw can allow unauthorized users to perform actions that should be restricted, such as approving financial transactions or manipulating inventory levels. The absence of proper authorization checks makes it possible for attackers to exploit these vulnerabilities, potentially leading to significant financial losses or operational disruptions.

![[UASBF.png]]

For example, consider an API used to approve financial transactions. If the API does not verify whether the user has the authority to approve transactions, any user could approve or modify transactions. This lack of restriction could lead to unauthorized financial operations, causing substantial damage to the organization's financial integrity.

**Example Scenario**: Imagine an online booking system for an airline. An attacker exploits a policy that imposes no cancellation fee. By reserving 90% of the seats on a flight, the attacker effectively blocks other potential customers from purchasing tickets. Then, just a few days before the flight, the attacker cancels all these reservations at no cost. As a result, the airline is forced to re-list the tickets at a discounted price to fill the flight. The attacker then buys a ticket at a significantly reduced price, taking advantage of the last-minute discounts. This exploitation not only causes financial losses to the airline but also disrupts its operations.

**Vulnerable Code Example**:

```python
# Flask endpoint for approving transactions
@app.route('/transactions/<int:transaction_id>/approve', methods=['POST'])
def approve_transaction(transaction_id):
    transaction = Transaction.query.get(transaction_id)
    if transaction:
        transaction.status = 'approved'
        db.session.commit()
        return jsonify({"message": "Transaction approved"})
    return jsonify({"error": "Transaction not found"}), 404
```

In this code snippet, the API endpoint allows users to approve transactions without verifying if the user has the proper authorization. Any user who knows a valid `transaction_id` can approve any transaction, which could lead to unauthorized approvals and financial discrepancies.

**Exploit Example**:

An attacker could exploit this vulnerability by sending the following HTTP request:

```http
POST /transactions/12345/approve
```

Without access controls, this request could be sent by any user to approve transaction ID 12345. If the system does not check whether the requester has the authority to approve the transaction, any user could use this method to approve unauthorized transactions.

#### Detection and Mitigation:

Detecting such vulnerabilities requires thorough security assessments and audits of access controls. Automated tools can help identify exposed business processes by scanning for endpoints that perform critical operations without proper authorization checks.

To mitigate this vulnerability, it is essential to enforce strict access controls and implement robust authorization checks for sensitive business processes. This involves verifying the user's identity and ensuring they have the necessary permissions before allowing access to critical functions. Additionally, implementing auditing and logging mechanisms can help track and monitor access to sensitive operations, providing a way to detect and respond to unauthorized access attempts.

### Server Side Request Forgery (SSRF)

Server Side Request Forgery (SSRF) is a vulnerability that arises when an attacker tricks a server into making unauthorized requests on their behalf. This can allow attackers to access internal resources or services that are not exposed to the public internet. SSRF exploits the trust that internal systems have in the server, potentially leading to unauthorized access to sensitive data or control over internal services.

In a typical SSRF attack, the attacker might receive direct feedback from the server about the unauthorized request, such as the data retrieved from an internal resource. However, in some cases, attackers may encounter **Blind SSRF** scenarios where no direct response is provided. This makes it challenging for the attacker to determine if their actions were successful. Attackers might resort to **partially-blind SSRF** techniques, where they analyze indirect clues such as Content-Length, response time, or HTTP status codes to infer the outcome of their requests.

**Example Scenario**: An attacker could exploit an SSRF vulnerability by sending a request to `https://api.example.com/proxy?url=http://internal-server/admin`. This request, processed by the vulnerable server, accesses internal resources like administrative pages that are not intended to be publicly accessible. This type of attack could expose sensitive data or allow unauthorized control over internal services.

**Vulnerable Code Example**:

```python
# Flask endpoint that acts as a proxy
@app.route('/proxy', methods=['GET'])
def proxy_request():
    url = request.args.get('url')
    response = requests.get(url)
    return (response.content, response.status_code, response.headers.items())
```

In this code snippet, the Flask API endpoint functions as a proxy, forwarding the request to any URL specified by the user. Since the server does not validate or restrict the URLs that can be accessed, an attacker can exploit this by sending requests to internal resources, leading to potential SSRF attacks.

**Exploit Example**:

An attacker might issue an HTTP request like this:

```http
GET https://api.example.com/proxy?url=http://internal-server/admin
```

This request makes the server fetch data from `http://internal-server/admin`, which could reveal sensitive internal information or enable unauthorized actions. The attacker uses this method to gain access to restricted resources or manipulate internal systems.

#### Detection & Mitigation

To detect SSRF vulnerabilities, monitoring server logs for unusual or unexpected requests is essential. Tools designed to identify SSRF issues, along with regular security assessments of server-side request handling, can help uncover these vulnerabilities.

Mitigating SSRF involves implementing robust input validation and sanitization to ensure that server-side requests are restricted to safe and intended URLs. Another critical measure is the use of allowlists, which restrict outgoing requests to only authorized destinations. This approach prevents unauthorized access to internal or sensitive resources. Additionally, network segmentation can limit the potential damage by isolating sensitive systems from general server requests. These practices collectively help protect against SSRF vulnerabilities and their associated risks.

#### Real-World Example: 2023 Attack on Rackspace

A notable instance of SSRF's impact is the [2023 attack on Rackspace](https://www.darkreading.com/remote-workforce/rackspace-massive-cleanup-costs-ransomware-attack?trk=article-ssr-frontend-pulse_little-text-block) by the group "Play Ransomware." Attackers exploited an SSRF-based Zero-Day vulnerability in Microsoft Exchange, leading to the blockage of all email access for Rackspace customers. The attack resulted in significant operational disruptions and financial losses estimated at $10 million and continuing. This case highlights the severe consequences that SSRF vulnerabilities can have when exploited, affecting both the targeted organization's infrastructure and its clients.

### Security Misconfiguration

Security Misconfiguration occurs when APIs or applications are deployed with insecure or default settings, making them vulnerable to attacks. Such misconfigurations can include using default credentials, enabling unnecessary debug information, or having overly permissive permissions. These issues often arise from inadequate security practices during the deployment phase, which leave the application exposed to potential exploits.

![[SM.png]]

**Example Scenario**: An API may be deployed with default database credentials such as `root` for the user and `password` for the password. If these credentials are not updated, an attacker can easily exploit them to gain unauthorized access to the database, potentially leading to a breach of sensitive information.

**Vulnerable Configuration Example**:

```plaintext
# Example configuration with default credentials
database:
  host: localhost
  user: root
  password: password
  database: mydatabase
```

In this example, the configuration file for the database includes default credentials that are commonly used. If these default settings are not changed, they pose a significant security risk. An attacker could exploit these credentials to access the database.

**Exploit Example**:

An attacker could use the following command to exploit the default credentials:

```bash
mysql -u root -p'password' -h localhost -D mydatabase
```

This command connects to the MySQL database using the default credentials, allowing the attacker to gain access to the database and potentially compromise the data.

#### Detection & Mitigation

To detect security misconfigurations, conducting thorough security audits and configuration reviews is crucial. Automated tools can assist in identifying insecure settings and configurations. Regular reviews of deployment settings are necessary to ensure that security best practices are followed.

Mitigating security misconfigurations involves adhering to secure configuration practices from the start. This includes changing default credentials to strong, unique ones and disabling unnecessary features or services that are not required for the application‚Äôs operation. Configuration management tools can help enforce secure settings across environments. Additionally, implementing automated processes for continuous assessment of configurations and parameters helps maintain security throughout the application's lifecycle.

#### Real-World Example: The Capital One Cloud Misconfiguration Breach

A prominent example of security misconfiguration is the [2019 breach of Capital One](https://www.fugue.co/blog/a-technical-analysis-of-the-capital-one-cloud-misconfiguration-breach), which resulted from multiple security issues, primarily a misconfigured Web Application Firewall (WAF). The breach occurred because Capital One used ModSecurity, an open-source WAF, to protect certain web applications and APIs. However, the WAF was not correctly configured for Capital One‚Äôs AWS environment, making it too permissive. This misconfiguration allowed an attacker to bypass the WAF‚Äôs content inspection and message filtering by exploiting a vulnerability to access the AWS cloud metadata service. This breach highlights how improper configuration can lead to significant security vulnerabilities, emphasizing the importance of securing deployment configurations effectively.

### Improper Inventory Management

Improper Inventory Management occurs when organizations fail to adequately track and manage their API versions and endpoints, which can lead to the presence of unmonitored vulnerabilities. This situation often arises when deprecated or outdated API versions remain accessible, despite being superseded by newer versions. These old versions might still harbor vulnerabilities that are no longer addressed, posing security risks to the system.

![[IIM.png]]

**Example Scenario**: Suppose an API version, such as `https://api.example.com/v1`, has been deprecated but remains accessible. This deprecated version might contain security flaws that have been patched in newer versions but are still exposed to potential attackers.

**Vulnerable Code Example**:

```python
# Flask endpoint for API version 1
@app.route('/api/v1/resource', methods=['GET'])
def get_resource_v1():
    # Handling for version 1 of the API
    return jsonify({"data": "Version 1"})
```

In this code snippet, the API version 1 endpoint remains accessible. If version 1 of the API has known vulnerabilities that are not present in the latest version, keeping it available can expose the system to those old vulnerabilities.

**Exploit Example**:

An attacker might exploit this vulnerability by accessing the deprecated API version with a simple HTTP request:

```http
GET https://api.example.com/api/v1/resource
```

If the deprecated API is still live, it can expose vulnerabilities that were fixed in later versions, potentially leading to unauthorized access or data breaches.

#### Detection & Mitigation

To detect issues related to improper inventory management, it is important to maintain a comprehensive inventory of all API versions and endpoints. Using automated tools to scan for unmonitored or deprecated APIs can help identify potential security risks. Regularly reviewing and updating the inventory ensures that all active and deprecated endpoints are accounted for and monitored.

Mitigating these issues involves updating and maintaining an accurate API inventory. Deprecated APIs should be properly decommissioned to prevent unauthorized access. Implementing a robust versioning strategy helps manage API updates and securely retire old versions. Additionally, active monitoring of all APIs, including those that are deprecated but still accessible, is crucial for maintaining security and addressing vulnerabilities in a timely manner.

#### Real-World Example: The Optus Breach

A significant example of the consequences of improper inventory management is the [data breach experienced by Optus](https://salt.security/blog/how-a-common-api-vulnerability-might-cost-telco-optus-1-million?), Australia's second-largest telecommunications company, in September 2022. The breach was caused by a security vulnerability in one of the company‚Äôs APIs, leading to the exposure of 11.2 million customer records, including personally identifiable information. The compromised API, used for managing customer accounts, had an issue that allowed unauthorized access to sensitive data such as names, addresses, and phone numbers.

This breach underscores the critical importance of proper API inventory management. When APIs are not regularly audited and assessed for security risks, vulnerabilities can remain undetected and exploited. In the case of Optus, the vulnerability was not identified until it had already been exploited, highlighting the need for diligent API management and regular security reviews to protect customer data and prevent such incidents.

### Unsafe Consumption of APIs

Unsafe Consumption of APIs occurs when applications integrate with external APIs without properly validating the data they receive. This practice can introduce significant security risks, as unvalidated data from an external source may contain malicious content. For example, if an application retrieves user data from an external API without validating the response, it could be vulnerable to attacks such as Cross-Site Scripting (XSS) or other forms of data injection.

![[UCA.png]]
**Example Scenario**: Suppose an application fetches user information from an external API endpoint at `https://external-api.com/userinfo`. If the application does not perform any validation or sanitization of the data received from this API, it might inadvertently process and display malicious content. This could lead to security issues like XSS attacks, where an attacker injects malicious scripts that execute in the context of a user's browser.

**Vulnerable Code Example**:

```python
# Flask endpoint consuming external API
@app.route('/consume', methods=['GET'])
def consume_external_api():
    response = requests.get('https://external-api.com/userinfo')
    return jsonify(response.json())
```

In this example, the Flask endpoint makes a request to an external API and returns the response directly to the client without any validation. If the external API sends back malicious data, it could compromise the security of the application.

**Exploit Example**:

An attacker could exploit this vulnerability by sending a request to the endpoint:

```http
GET https://api.example.com/consume
```

If the external API responds with malicious data that the application does not validate, it might lead to XSS attacks or other forms of exploitation, depending on the nature of the data and how it is handled.

#### Detection & Mitigation

To detect unsafe consumption of APIs, it is important to assess how third-party APIs are used and validate the data received from them. Regular reviews of API consumption practices and monitoring for unusual activity can help identify potential security issues.

Mitigating these risks involves several practices. First, data received from external APIs should always be validated and sanitized before being used or displayed. Using secure communication channels such as HTTPS is also crucial to protect data integrity and confidentiality. Additionally, implementing input validation and output encoding helps prevent the execution of malicious code. Ensuring that external APIs are trusted and verified before integration can further reduce the risk of incorporating insecure data sources.

#### Real-World Example: The Log4Shell Vulnerability

The [Log4Shell](https://www.dynatrace.com/news/blog/what-is-log4shell/) vulnerability, discovered in December 2021, provides a stark example of the consequences of unsafe API consumption. This critical flaw was found in the widely-used Apache Log4j logging library and allowed attackers to execute arbitrary code on nearly every web service that utilized the library. The vulnerability stemmed from the unsafe deserialization of user-supplied data, which was not properly validated.

Attackers exploited this flaw by sending requests with malicious payloads that Log4j would then process and execute. The widespread use of Log4j meant that this vulnerability had a broad impact, affecting countless systems globally. The Log4Shell incident underscored the importance of securely handling and validating external data, particularly when it involves deserialization. It highlighted the need for rigorous input validation and careful handling of data from external sources to prevent similar vulnerabilities.

## Resources:

### Real World Attack:

- [**Broken Object Level Authorization:**](https://money.cnn.com/2016/12/02/technology/russia-central-bank-hack/)
- [**Broken Authentication**](https://salt.security/blog/unpacking-the-parler-data-breach?)
- [**Broken Object Property Level Authorization**](https://privacy.twitter.com/en/blog/2022/an-issue-affecting-some-anonymous-accounts)
- [**Unrestricted Resource Consumption**](https://www.bloomberg.com/news/articles/2023-03-01/poland-points-finger-at-russia-over-ddos-attack-on-nation-s-key-tax-portal#xj4y7vzkg)
- [**Server Side Request Forgery (API version)**](https://www.darkreading.com/remote-workforce/rackspace-massive-cleanup-costs-ransomware-attack?trk=article-ssr-frontend-pulse_little-text-block)
- [**Security Misconfiguration**](https://www.fugue.co/blog/a-technical-analysis-of-the-capital-one-cloud-misconfiguration-breach)
- [**Improper Inventory Management**](https://salt.security/blog/how-a-common-api-vulnerability-might-cost-telco-optus-1-million?)
- [**Unsafe Consumption of APIs**](https://www.dynatrace.com/news/blog/what-is-log4shell/)

### Misc:

- [MyF5 Guide API OWASP Top 10](https://my.f5.com/manage/s/article/K000135973)
- [Salt Security Blog](https://salt.security/blog)
