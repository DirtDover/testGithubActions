# JWT (JSON Web Token)

## What you will learn in this course üßêüßê

- Understand the concept of JSON Web Tokens (JWT)
- Learn why JWTs are used in web applications and APIs
- Explore you can exploit JWT vulnerabilities

JWT (JSON Web Token) is a standardized format for securely transmitting information between parties as a JSON object. It serves primarily for authentication and authorization in web applications and APIs.

## Why Use JWT?

JWT offers simplicity and compactness in data transmission. Its JSON structure makes integration into HTTP headers, URLs, and POST data straightforward. By containing all necessary information within itself, JWT reduces the need for frequent database queries to verify user credentials, enhancing performance and efficiency.

In terms of security, JWTs employ cryptographic algorithms to ensure data integrity and authenticity. This means that once a JWT is signed by the server with a secret key or a pair of public-private keys, any tampering attempts can be detected. This makes JWTs reliable for verifying the legitimacy of user requests without depending on centralized session management.

### Structure and Usage of JWT

A JWT comprises three main parts:

- **Header:** Specifies the token type (JWT) and the algorithm used for signing.
- **Payload:** Contains claims, which are statements about an entity (typically the user) and additional data. These claims are encoded within the JWT.
- **Signature:** Created by combining the encoded header, payload, and a secret key. This ensures that the JWT has not been altered during transmission and can be trusted.

JWTs are generated by the server upon successful authentication of a user. Once issued, they are sent to the client, usually stored in local storage, cookies, or as part of the Authorization header in subsequent requests. The server validates incoming JWTs by verifying the signature using the secret key. If valid, the server extracts and uses the information contained in the payload to authorize access to protected resources.

### Practical Use Case

Imagine a scenario where a user logs into an application. After successful authentication, the server generates a JWT containing user details and permissions. This token is then sent back to the client, where it is stored securely. For every subsequent request to access protected resources (like APIs or restricted web pages), the client includes the JWT in the request headers. The server verifies the token's validity and uses the information within to determine whether the request should be authorized or denied.

In essence, JWTs streamline the authentication and authorization processes in web applications and APIs by securely transmitting user information and permissions between client and server. They provide a decentralized and efficient way to manage user sessions and ensure secure data exchange across different domains and services.

## Exploitation

Attackers exploit JWT vulnerabilities by modifying token data (payload or signature) or by crafting tokens with manipulated claims to escalate privileges or impersonate other users. This can occur due to weak token encryption, insufficient signature validation, or improper token storage and transmission practices.The different steps to corrupt a JWT look like this:

1. The attacker manipulates JWT data or crafts forged tokens.
2. This allows unauthorized access or impersonation by bypassing authentication mechanisms.
3. The attacker gains access to protected resources or performs actions on behalf of other users.

![JWT](<https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D05-Web_Pentesting_02/01-lectures/JWT.png>)

### Signature Verification Bypass

#### None Algorithm Vulnerability

JWTs can be signed using various algorithms, and the `alg` header specifies the algorithm used for signing the token. Some servers fail to properly handle the `none` algorithm, which indicates no signature. This can be exploited by an attacker to bypass signature verification altogether.

- **Detailed Vulnerable Code Example**:

```php
<?php
// Simplistic JWT verification
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);
$payload = json_decode(base64_decode($parts[1]), true);

// Check algorithm and verify signature if necessary
if ($header['alg'] === 'HS256') {
  // Signature verification logic
} elseif ($header['alg'] === 'none') {
  // No signature verification for 'none' algorithm
}
?>
```

- **Exploitation**:

An attacker can construct a JWT with the `alg` header set to `none` and omit the signature part:

```plaintext
Header: { "alg": "none", "typ": "JWT" }
Payload: { "sub": "user1", "role": "admin" }
Signature: (none)
```

This token would be accepted as valid if the server doesn‚Äôt enforce signature verification when `alg` is `none`.

#### Algorithm Confusion

In some cases, the server may incorrectly process JWTs if the algorithm in the header differs from what is expected. For instance, switching from RS256 (asymmetric) to HS256 (symmetric) could cause the server to misinterpret the public key as a secret key.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT verification with algorithm check
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);

if ($header['alg'] === 'RS256') {
  // Verify with RS256 private key
} elseif ($header['alg'] === 'HS256') {
  // Verify with HS256 secret key
}
?>
```

- **Exploitation**:

An attacker might manipulate the `alg` header to `HS256` and craft a token using a public key as a symmetric key:

```plaintext
Header: { "alg": "HS256", "typ": "JWT" }
Payload: { "sub": "user1", "role": "admin" }
Signature: (signed with the public key)
```

If the server mistakenly uses the public key as the secret key, the attacker‚Äôs token could be validated incorrectly.

### Key Manipulation

#### Key Injection

JWTs often use a `kid` (key ID) to specify which key should be used for signature verification. Attackers can exploit this by injecting a key ID that points to a malicious key, tricking the server into using it.

- **Detailed Vulnerable Code Example**:

```php
<?php
// Key retrieval based on 'kid'
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);
$payload = json_decode(base64_decode($parts[1]), true);

$key = get_key_by_kid($header['kid']); // Fetch key from key store
// Verify JWT using the fetched key
?>
```

- **Exploitation**:

An attacker can set the `kid` parameter to a value that points to a malicious key:

```plaintext
Header: { "alg": "RS256", "kid": "malicious-key-id" }
Payload: { "sub": "user1" }
Signature: (signed with the attacker‚Äôs key)
```

If the server retrieves and uses the attacker‚Äôs key for verification, it could accept forged tokens.

#### JWKS Spoofing

The `jku` (JSON Web Key Set URL) header allows servers to retrieve keys from a remote URL. An attacker can manipulate this header to point to a malicious server that provides a forged JWKS.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT verification with JWKS
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);

if (isset($header['jku'])) {
  $key_set = fetch_jwks($header['jku']); // Fetch JWKS from URL
  // Use the keys from JWKS to verify the JWT
}
?>
```

- **Exploitation**:

The attacker sets the `jku` header to a URL they control:

```plaintext
Header: { "alg": "RS256", "jku": "http://malicious-server.com/jwks" }
Payload: { "sub": "user1" }
Signature: (signed with a key from malicious JWKS)
```

The server retrieves a malicious JWKS and uses its keys to verify the JWT, allowing the attacker to forge tokens.

### Kid Claim Exploitation

#### Path Traversal

If the `kid` parameter is used to access files, attackers can exploit path traversal vulnerabilities to access unauthorized files.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT verification with file-based keys
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);

$key_path = '/keys/' . $header['kid'] . '.key'; // Path to key file
$key = file_get_contents($key_path);
// Use the key to verify the JWT
?>
```

- **Exploitation**:

An attacker could set the `kid` parameter to include directory traversal sequences:

```plaintext
Header: { "alg": "RS256", "kid": "../../../../../etc/passwd" }
Payload: { "sub": "user1" }
Signature: (signed with a valid key)
```

This could expose sensitive files from the server.

#### SQL Injection

If the `kid` parameter is used directly in SQL queries, attackers can perform SQL injection to manipulate the query.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT verification with SQL key retrieval
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);

$query = "SELECT key_data FROM keys WHERE kid = '" . $header['kid'] . "'";
$result = mysqli_query($conn, $query);
$key_data = mysqli_fetch_assoc($result)['key_data'];
// Use the key data to verify the JWT
?>
```

- **Exploitation**:

An attacker might inject SQL code into the `kid` parameter:

```plaintext
Header: { "alg": "RS256", "kid": "' OR '1'='1" }
Payload: { "sub": "user1" }
Signature: (signed with the key retrieved from SQL injection)
```

This could lead to unauthorized data retrieval or modification.

#### OS Command Injection

If the `kid` parameter is used in OS command execution, attackers can inject arbitrary commands.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT verification with OS command
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);

$command = "cat /keys/" . escapeshellarg($header['kid']) . ".key";
$key = shell_exec($command);
// Use the key to verify the JWT
?>
```

- **Exploitation**:

An attacker can inject commands via the `kid` parameter:

```plaintext
Header: { "alg": "RS256", "kid": "evil_script.sh; rm -rf /important_files" }
Payload: { "sub": "user1" }
Signature: (signed with a key from command injection)
```

This could execute unwanted commands on the server.

### Header Manipulation

#### x5u and jku Headers

In the context of JSON Web Tokens (JWTs), the `x5u` and `jku` headers are used to specify external resources from which cryptographic keys or certificates can be fetched for token verification. The `x5u` (X.509 URL) header indicates a URL where an X.509 certificate can be obtained, while the `jku` (JSON Web Key Set URL) header provides a URL pointing to a JSON Web Key Set (JWKS) containing public keys used to verify the JWT signature. Both headers enable dynamic retrieval of verification keys, but they also introduce potential security risks. Attackers can manipulate these headers to point to malicious URLs, potentially leading to server-side request forgery (SSRF) or other attacks.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT verification with external certificates
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);

if (isset($header['x5u'])) {
  $cert_url = $header['x5u'];
  $certificate = file_get_contents($cert_url); // Fetch certificate
  // Use the certificate to verify JWT
}
?>
```

- **Exploitation**:

An attacker can set the `x5u` header to a URL they control:

```plaintext
Header: { "alg": "RS256",
"x5u": "http://malicious-server.com/certificate.pem" }
Payload: { "sub": "user1" }
Signature: (signed with a key using the malicious certificate)
```

This could lead to unauthorized token validation using an attacker‚Äôs certificate.

#### x5c Header Manipulation

The `x5c` header contains a chain of certificates. Replacing these certificates with an attacker-controlled certificate could forge a valid JWT.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT verification with x5c certificates
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$header = json_decode(base64_decode($parts[0]), true);

if (isset($header['x5c'])) {
$certs = $header['x5c'];
$cert = implode("\n", $certs);
// Use the certificate to verify JWT
}
?>
```

- **Exploitation**:

Replace the certificate with a malicious one:

```plaintext
Header: { "alg": "RS256", "x5c": ["MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7k7t5yr9vNn3VVH4o3i"] }
Payload: { "sub": "user1" }
Signature: (signed with the malicious certificate)
```

This token would be accepted as valid if the server uses the attacker‚Äôs certificate.

### Token Replay and Expiry

#### Token Replay

JWTs that are not correctly managed in terms of expiration or session handling can be replayed by attackers. Captured tokens can be reused to gain unauthorized access.

- **Detailed Vulnerable Code Example**:

```php
<?php
// Token validation with expiration check
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$payload = json_decode(base64_decode($parts[1]), true);

if (isset($payload['exp']) && $payload['exp'] < time()) {
  // Token expired, handle accordingly
}
?>
```

- **Exploitation**:

Capture and reuse a valid token before it expires:

```plaintext
Header: { "alg": "HS256", "typ": "JWT" }
Payload: { "sub": "user1", "exp": 1716297477 } // Valid expiration timestamp
Signature: (signed with a valid key)
```

#### Expiry Manipulation

Attackers can manipulate the `exp` claim to test if the server correctly handles expired tokens. This can be used to bypass expiry checks.

- **Detailed Vulnerable Code Example**:

```php
<?php
// Token validation with expired tokens
$jwt = $_GET['token'];
$parts = explode('.', $jwt);
$payload = json_decode(base64_decode($parts[1]), true);

if (isset($payload['exp']) && $payload['exp'] < time()) {
  // Token is expired
  // Handle expiration
}
?>
```

- **Exploitation**:

Create a token with an expired `exp` claim:

```plaintext
Header: { "alg": "HS256", "typ": "JWT" }
Payload: { "sub": "user1", "exp": 0 }  // Expired timestamp
Signature: (signed with a valid key)
```

Test if the server incorrectly accepts the expired token.

### Cross-Service Relay Attacks

If JWTs from a trusted service are used across different services, an attacker can relay a valid token from one service to another. This can grant unauthorized access if the second service accepts the token.

- **Detailed Vulnerable Code Example**:

```php
<?php
// JWT usage across services
$jwt = $_GET['token'];
// Use the token in different contexts or services
?>
```

- **Exploitation**:

Capture a token from one service and use it in another:

```plaintext
Header: { "alg": "HS256", "typ": "JWT" }
Payload: { "sub": "user1" }
Signature: (signed with a valid key for the first service)
```

Use this token in another service that doesn‚Äôt validate the service context, gaining unauthorized access.

## Mitigation Techniques

To safeguard against JWT vulnerabilities, begin by adopting strong cryptographic algorithms like RS256 or ES256 for signing tokens. These algorithms provide robust security and help ensure that JWTs are difficult for attackers to forge. Avoid using weaker algorithms or the `none` algorithm, which bypasses signature verification and renders the token susceptible to tampering.

For each JWT, implement thorough signature validation. This involves confirming that the JWT‚Äôs signature matches the expected one using the correct cryptographic key and algorithm. Key management practices are also crucial; protect cryptographic keys through stringent access controls and consider utilizing hardware security modules (HSMs) to enhance their security.

Define clear token expiration policies to limit the window during which a token is valid. Set appropriate expiration times using the `exp` claim, and implement a robust token revocation mechanism to invalidate tokens promptly, such as when a user logs out or changes their password.

Ensure that JWTs are transmitted securely by always using HTTPS to prevent interception or tampering. Store tokens in secure locations, such as HTTP-only cookies, to protect them from unauthorized access.

Sanitize and validate all JWT-related inputs, including headers like `kid`, `x5u`, and `jku`, to mitigate the risk of injection attacks and ensure the secure handling of tokens. Limit the scope of tokens to include only the necessary claims, thereby minimizing the risk of unauthorized access.

Here's an example of how to securely handle JWTs in PHP, addressing key security concerns:

```php
<?php
require 'vendor/autoload.php'; // Include JWT library
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

// Define the secret key and algorithm
$secretKey = 'your-256-bit-secret';
$algorithm = 'HS256';

// Retrieve and decode the JWT from the request
$jwt = $_GET['token'] ?? '';
if (!$jwt) {
    die('Token is required');
}

try {
    // Decode the JWT using the secret key and algorithm
    $decoded = JWT::decode($jwt, new Key($secretKey, $algorithm));

    // Validate claims
    $currentTime = time();
    if ($decoded->exp < $currentTime) {
        die('Token has expired');
    }

    if ($decoded->aud !== 'expected_audience') {
        die('Invalid audience');
    }

    if ($decoded->iss !== 'expected_issuer') {
        die('Invalid issuer');
    }

    // Successfully decoded and validated
    echo "User ID: " . htmlspecialchars($decoded->sub) . "<br />";
    echo "Role: " . htmlspecialchars($decoded->role) . "<br />";

} catch (Exception $e) {
    die('Invalid token: ' . $e->getMessage());
}
?>
```

In this example, the JWT is decoded using the `Firebase\JWT\JWT` library. The `decode` function verifies the token's signature with the provided secret key and algorithm. It also checks that the token has not expired and that the `aud` (audience) and `iss` (issuer) claims are valid. If any validation fails, the script provides appropriate error messages. This approach ensures secure JWT handling by verifying token integrity and validating claims, thus protecting against common JWT vulnerabilities.

## Detection Techniques

Detecting JWT vulnerabilities involves a multi-faceted approach. Regular security audits and vulnerability assessments should focus on JWT implementation and token management practices to identify and address potential issues. Monitoring and logging JWT activity provides valuable insights into token creation, usage, and validation, allowing for the detection of suspicious behavior, such as abnormal issuance patterns or failed validation attempts. Analyzing JWT claims and headers for anomalies is crucial; ensure that claims like `exp`, `aud`, and `iss` are correctly validated and conform to expected values.

To detect token abuse or anomalies, intrusion detection systems (IDS) and security information and event management (SIEM) solutions can be employed. These tools help identify unusual patterns, such as the use of expired or forged tokens. Automated security tools and penetration testing techniques should also be used to uncover common vulnerabilities related to JWTs, such as signature verification bypass and key injection. Reviewing token handling practices regularly ensures that all aspects of JWT verification adhere to security best practices and that any deprecated or insecure algorithms are eliminated. Finally, implementing and maintaining token revocation mechanisms allows for the prompt invalidation of compromised tokens, enhancing overall security.

## Resources

- [PortSwigger JWT](https://portswigger.net/web-security/jwt)
- [10 ways to exploit JWT](https://medium.com/@musab_alharany/10-ways-to-exploit-json-web-token-jwt-ac5f4efbc41b)
