# Security Risks

## What you will learn in this course üßêüßê

- Understand the critical vulnerabilities in CI/CD environments

The CI/CD pipeline is pivotal in modern software development, automating the process from code creation to deployment. However, the complexity and interconnected nature of CI/CD environments introduce significant security challenges. Here, we explore several critical vulnerabilities and their potential impacts on CI/CD security:

## 1. Insufficient Flow Control Mechanisms

Insufficient flow control mechanisms describe a scenario where an attacker with permissions to a system within the CI/CD process (such as SCM, CI, or Artifact repository) can autonomously introduce malicious code or artifacts into the pipeline. This occurs because there are inadequate mechanisms in place to enforce additional approvals or reviews before changes are propagated downstream.

<Note type="tip" title="Reminder">

### SCM (Source Code Management)

SCM, or **Source Code Management**, is a system used to track and manage changes to the source code throughout the software development lifecycle. It allows developers to collaborate effectively by keeping a record of all changes, which helps in team collaboration, merging changes, and version management. SCM systems like [Git](https://git-scm.com/) offer features such as version control, branching, and change history tracking. This ensures that the code is organized and that changes can be easily traced and reverted if necessary.

### CI (Continuous Integration)

CI, or **Continuous Integration**, is a software development practice where developers frequently integrate their code changes into a shared repository. Each integration is automatically tested using a build system that compiles the code and runs automated tests (unit tests, integration tests, etc.). The goal of CI is to quickly detect and fix errors, reduce integration conflicts, and ensure that the software remains in a working state throughout the development process. Tools like [Jenkins](https://www.jenkins.io/), [Travis CI](https://www.travis-ci.com/), and [GitHub Actions](https://github.com/features/actions) are commonly used to set up CI pipelines.

### Artifact Repository

An **Artifact Repository** is a system for storing and managing the artifacts generated during the software build process. Artifacts can include executable files, libraries, packages, or any other form of binary file that results from compiling the source code. An artifact repository provides a centralized location for storing these artifacts, making it easier to reuse and distribute them across different stages of the CI/CD pipeline. Tools like [Artifactory](https://jfrog.com/artifactory/) or [Nexus Repository](https://www.sonatype.com/products/repository-oss) are often used to manage artifacts, offering features like versioning, access control, and integration with other build and deployment tools.

</Note>

## 2. Inadequate Identity and Access Management

Inadequate identity and access management, involves difficulties managing the vast number of identities spread across different systems in the engineering ecosystem, from source control to deployment. The existence of poorly managed identities in the CI/CD environment (both human and machine, or programmatic) increases the potential for compromise, as well as the extent of damage in the event of a security breach. Key concerns and challenges in identity and access management within the CI/CD ecosystem are:

- **Overly permissive identities**: Ensuring that each human and application identity has precisely the permissions necessary, limited to the specific repositories or resources they require access to within SCMs.

- **Stale identities**: Managing accounts of employees or systems that are no longer active or need access, but have not been properly deprovisioned across all CI/CD systems.

- **Local identities**: Handling identities managed locally within systems without federating access to a centralized Identity Provider (IDP). This creates inconsistencies in enforcing security policies like password strength, lockout rules, and Multi-Factor Authentication (MFA), and complicates deprovisioning access uniformly.

- **External identities**: Managing accounts associated with email domains not owned or managed by the organization. The security of these accounts depends on the external provider's security practices, which may not align with the organization‚Äôs policies.

- **External collaborators**: When granting access to external collaborators, the security posture of the system is influenced by the collaborator's own security environment outside the organization‚Äôs control.

- **Self-registered identities**: Systems allowing self-registration based solely on a valid domain address may inadvertently grant broader access than intended, potentially increasing the attack surface.

- **Shared identities**: Shared accounts between human users, applications, or both, expand the potential risk associated with credential compromise and pose challenges in accountability during security investigations.

## 3. Dependency Chain Abuse

**Dependency Chain Abuse** refers to an attacker exploiting weaknesses in how code dependencies are managed and fetched in engineering workstations and build environments. This type of attack can lead to a malicious package being unintentionally downloaded and executed locally. Key attack vectors in this domain include:

- **Dependency Confusion**: Malicious packages are published in public repositories with the same names as internal packages. This can trick systems into downloading the malicious version instead of the intended private one.

- **Dependency Hijacking**: Attackers gain control over a package maintainer's account on a public repository to upload a malicious version of a widely-used package. When clients update to the latest version, they inadvertently pull the malicious package.

- **Typosquatting**: Malicious packages are created with names similar to popular, legitimate packages. Developers who mistype the package name can accidentally download and use the malicious package.

- **Brandjacking**: Malicious packages mimic the naming conventions or other characteristics of trusted packages from well-known brands. This deception leads developers to trust and use the malicious package under false pretenses.

## 4. Poisoned Pipeline Execution (PPE)

Poisoned Pipeline Execution (PPE) exploits permissions in a Source Control Management (SCM) repository to manipulate a CI pipeline and execute harmful commands. Users with the necessary permissions can modify CI configuration files or other files used by the pipeline job to include malicious commands. This "poisons" the CI pipeline, leading to the execution of these malicious commands. For a malicious actor to successfully perform a PPE attack, they need to:

- **Have write access** to the VCS platform, as pipelines are usually triggered when a push or a pull request is performed. Sometimes, an external pull request counts as "write access."
- Ensure they can **modify the CI config file** or other files the config relies on. This might require bypassing branch protections.

There are three PPE variants:

1. **Direct PPE (D-PPE)**: This occurs when the actor modifies the CI config file that will be executed.

2. **Indirect PPE (I-DPE)**: This occurs when the actor modifies a file that the CI config file relies on, such as a makefile or a Terraform config.

3. **Public PPE or 3PE**: In some cases, pipelines can be triggered by users who don't have write access to the repo (and might not even be part of the organization) because they can send a pull request.

**3PE Command Injection**: CI/CD pipelines often set environment variables with information about the pull request. If an attacker can control that value (like the title of the pull request) and it is used in a dangerous place (like executing shell commands), the attacker might inject commands there.

## 5. Insufficient PBAC (Pipeline-Based Access Controls)

**Pipeline execution nodes** have broad access to both internal and external resources in their environment. If attackers run harmful code within a pipeline, they can take advantage of weak **Pipeline-Based Access Controls (PBAC)**. This could allow them to move around and access other parts of the CI/CD system or even outside it.

Pipelines serve as the core operations hub in CI/CD workflows. Nodes executing pipelines execute commands specified in the pipeline configuration, facilitating a range of critical activities:

- Accessing source code, building, and testing it.
- Retrieving secrets from various sources such as environment variables, vaults, and cloud-based identity services like AWS metadata service.
- Creating, modifying, and deploying artifacts.

PBAC encompasses the specific context in which each pipeline and its individual steps operate. Given the sensitivity and importance of these processes, it is crucial to restrict each pipeline strictly to the data and resources essential for its tasks. Ideally, these restrictions minimize potential damage in the event that malicious code is executed within the pipeline context. PBAC controls encompass various elements within the pipeline execution environment:

- Access controls within the pipeline environment, including code, secrets, environment variables, and interactions with other pipelines.
- Permissions governing access to the underlying host and other nodes within the pipeline infrastructure.
- Ingress and egress filters regulating internet connectivity to prevent unauthorized data transfers.

## 6. Insufficient Credential Hygiene

Application credentials are crucial for runtime operations, while production system credentials enable pipelines to deploy infrastructure, artifacts, and applications into production environments. Engineers also rely on credentials within testing environments and embedded within their code and artifacts.

This diversity of contexts, coupled with various storage and usage methods, creates ample opportunities for insecure credential practices. Major vulnerabilities impacting credential hygiene include:

- **Inadvertent exposure in SCM repositories**: Credentials embedded within code pushed to SCM branches can be unintentionally exposed to anyone with repository access. Even if removed from the active branch, they remain visible in the commit history.

- **Insecure usage in build and deployment processes**: Credentials used across multiple pipelines and target systems must be carefully managed. It's essential to clarify:

    - How each set of credentials is utilized and secured.
    - Whether pipelines access only the necessary credentials.
    - Risks associated with unreviewed code accessing credentials during pipeline execution.
    - Secure handling and injection of credentials during builds and deployments.

- **Credentials in container image layers**: Credentials necessary for image builds can linger in image layers, potentially accessible to unauthorized parties who download the image.

- **Console output exposure**: Credentials used in pipelines are sometimes inadvertently exposed in plaintext within console outputs or logs, increasing their exposure to anyone with access to build results or log management systems.

- **Stale credentials**: Failing to regularly rotate credentials exposes them to a broad array of personnel and systems within the engineering ecosystem. This is particularly problematic for long-lived credentials like deploy keys managed under outdated security practices.

## 7. Insecure System Configuration

CI/CD environments encompass a multitude of systems from various vendors. Securing these environments effectively requires a dual focus on the integrity of code and artifacts flowing through the pipelines, as well as the robustness and resilience of each individual system.

Similar to other data-processing systems, CI/CD systems involve comprehensive security settings and configurations across application, network, and infrastructure layers. These configurations significantly influence the overall security stance of CI/CD environments and their susceptibility to potential compromises. Attackers of varying sophistication actively seek out vulnerabilities and misconfigurations within CI/CD setups that they can exploit to their advantage. Examples of potential vulnerabilities in need of hardening include:

- **Outdated or unpatched self-managed components**: Systems or components running on outdated versions lacking critical security patches pose significant risks.

- **Overly permissive network access controls**: Misconfigured network settings that grant excessive access increase the attack surface for malicious actors.

- **Administrative permissions on self-hosted systems**: Systems with administrative privileges on the underlying operating system are particularly vulnerable to exploitation.

- **Insecure system configurations**: Default configurations often lack essential security features such as proper authorization, access controls, and robust logging, necessitating thorough optimization.

- **Inadequate credential hygiene**: Issues like default credentials left enabled, overly permissive programmatic tokens, and similar flaws undermine the security posture of CI/CD systems.

### How to Find Good Configurations

Ensuring that CI/CD systems are configured securely requires a systematic approach to identifying and implementing optimal configurations. Start by conducting regular security audits of your CI/CD environments. This process involves a thorough review of configuration settings across all systems, pinpointing potential weaknesses, and ensuring compliance with established security policies. Referring to industry standards and best practices is also essential; frameworks and guidelines provided by organizations such as the Center for Internet Security (CIS), the National Institute of Standards and Technology (NIST), and the Open Web Application Security Project (OWASP) offer valuable benchmarks tailored to enhancing the security of CI/CD systems.

Incorporating automated configuration management tools like Ansible, Chef, or Puppet can significantly streamline the deployment of secure configurations, ensuring consistency and compliance while allowing for rapid changes when necessary. Regular vulnerability scans are crucial for continuously assessing the security posture of your CI/CD systems, helping to detect misconfigurations, outdated components, and other vulnerabilities that may arise. It is equally important to enforce strict access controls by applying the principle of least privilege. This involves carefully managing access rights to ensure that only authorized personnel can reach sensitive areas and systems within the CI/CD environment.

Keeping all components of the CI/CD pipeline up-to-date is another vital practice. Regular updates to operating systems, applications, and dependencies help to mitigate the risk of exploitation from known vulnerabilities. Finally, establishing comprehensive logging and monitoring is essential for tracking activities within CI/CD systems. Implementing Security Information and Event Management (SIEM) solutions can aggregate and analyze logs effectively, enabling the detection and prompt response to suspicious activities in real time. By adopting these practices, organizations can better secure their CI/CD systems, reducing the likelihood of compromises and maintaining the integrity of their operational environments.

### 8. Ungoverned Usage of 3rd Party Services

It's uncommon to find an organization without multiple third parties integrated into its CI/CD systems and processes. Third parties refer to external companies, services, or software tools that an organization uses to enhance its CI/CD pipelines. These might include cloud service providers, software vendors, security tools, or API services that offer additional functionalities or integrations. The simplicity and immediate benefits of these integrations have made third parties integral to daily engineering operations. Methods for embedding or granting access to third parties have become increasingly diverse and less complex to implement.

Using GitHub SaaS as an example, third-party applications can connect through one or more of these methods:

- **GitHub Applications**: Use GitHub Apps for integration where possible, as they utilize specific access tokens that provide granular permission control. This approach allows for more precise management of what the third party can do compared to OAuth tokens.
- **OAuth Applications**: Limit the permissions granted to OAuth tokens. Regularly review and revoke tokens that are no longer needed. Ensure that OAuth applications request the minimum access necessary for their operation.
- **Access Tokens**: Protect access tokens by storing them in a secure secrets manager. Implement token expiration policies and rotate tokens regularly. Avoid hardcoding tokens directly in your source code.
- **SSH Keys**: Use SSH keys with appropriate restrictions. Ensure private keys are not shared and implement robust key management practices, including key rotation and revocation.
- **Webhooks**: Configure webhooks to trigger events only for specific actions. Secure webhook endpoints with authentication mechanisms to prevent unauthorized access and abuse.

Each method typically takes seconds to minutes to implement and grants third parties varying degrees of capabilities, from reading code in a single repository to full administrative control over the GitHub organization. Despite the potentially high level of permissions granted, many organizations do not require special permissions or approvals prior to implementation.

Integration of third parties into build systems is similarly straightforward. Adding third parties to build pipelines often involves minimal configuration, such as adding a few lines of code to the pipeline configuration file or installing a plugin from the build system‚Äôs marketplace (e.g., actions in GitHub Actions, Orbs in CircleCI). Once integrated, third-party functionalities execute within the build process, leveraging resources available at the pipeline stage.

### Safe Integration of Third-Party Services

To ensure safe integration of third-party services, organizations should adopt a comprehensive security approach. Begin by assessing the necessity of each third-party service, ensuring that **only essential integrations are allowed**. Always prefer **using GitHub Applications over OAuth tokens** due to their capability for more granular permission control. When OAuth is used, **restrict permissions to the minimum necessary**, and regularly audit and revoke any tokens that are not in use.

Access tokens should be **securely managed, stored in a secrets manager, and regularly rotated** to prevent unauthorized use. Avoid **hardcoding tokens into source code** to minimize the risk of accidental exposure. For SSH keys, **enforce strict usage policies**, ensuring they are never shared and are subject to regular rotation and revocation.

Webhooks should be configured to **react only to specific, necessary events**, and all webhook endpoints must be secured with **robust authentication mechanisms** to prevent unauthorized access. Additionally, organizations should **establish clear policies** for third-party access and regularly review these integrations to ensure compliance with security standards.

## 9. Improper Artifact Integrity Validation

CI/CD processes involve a series of interconnected stages that transition code from an engineer's workstation to a production environment. Throughout this journey, various resources such as internal assets, build artifacts, and third-party packages are integrated. Each step of the pipeline, including code commits, builds, and deployments, may involve multiple systems and contributors, each representing potential entry points for compromise.

For instance, consider a scenario where a third-party library, such as an open-source component or a commercial dependency, is integrated into your build pipeline. If this library is compromised, a malicious actor could inject harmful code into the library, which then becomes part of your build artifacts. Without proper integrity checks, this tainted library can seamlessly move through the pipeline, being tested and reviewed as if it were safe. Eventually, it may be deployed to production, posing a significant risk.

Similarly, if internal build artifacts such as compiled binaries or container images are not properly validated, a compromised artifact could be introduced through an insecure build environment or a tampered artifact repository. For example, if an attacker gains access to your artifact repository, they might replace legitimate binaries with malicious ones, which could then be unknowingly deployed to production.

### Mitigation

To mitigate these risks, implement robust artifact integrity validation practices. Use cryptographic hash functions (like SHA-256) to verify the integrity of artifacts at each stage of the pipeline. For example, compute and compare hash values for artifacts before and after critical steps, such as builds and deployments. Employ digital signatures to ensure that artifacts are authentic and have not been altered. This way, any tampering can be detected and addressed before reaching production.

Additionally, secure your artifact repositories with strong access controls and regularly audit them for unauthorized changes. For third-party packages, validate their integrity and authenticity using trusted sources or hash comparisons. Integrate automated integrity checks into your CI/CD pipeline to enforce these practices consistently and reduce the risk of human error.

## 10. Insufficient Logging and Visibility

The existence of strong logging and visibility capabilities is essential for an organization‚Äôs ability to prepare for, detect and investigate a security related incident.

While workstations, servers, network devices, key IT and business applications are typically covered in depth within an organization‚Äôs logging and visibility programs, it is often not the case with systems and processes in engineering environments.

Given the amount of potential attack vectors leveraging engineering environments and processes it is imperative that security teams build the appropriate capabilities to detect these attacks as soon as they happen. As many of these vectors involve leveraging programmatic access against the different systems, a key aspect of facing this challenge is to create strong levels of visibility around both human and programmatic access.

## Resources

- [Mastering CI/CD Security](https://hackernoon.com/mastering-cicd-security-a-step-by-step-guide-for-beginners-and-beyond)
- [CI/CD Risk & 20 Best Pratice](https://spacelift.io/blog/ci-cd-security)
