# Pentesting Methodology

## What you will learn in this course üßêüßê

- Pentesting Methodology for Version Control Systems (VCS)
- Pentesting Methodology for CI/CD Pipelines

We are now going to focuses on the security of Version Control Systems (VCS) and CI/CD pipelines, both critical components in modern software development. A VCS helps track and manage changes to source code, but it also introduces unique security challenges, such as protecting code integrity, managing access, and preventing the leakage of sensitive information. Similarly, CI/CD pipelines, which automate development and deployment processes, can become targets for attacks aiming to inject malicious code or steal sensitive data. This lecture addresses common vulnerabilities associated with these technologies and provides methodologies for testing them, focusing on popular platforms like GitHub, GitLab, BitBucket, and pipeline tools like Jenkins and Terraform.

## VCS Pentesting

A Version Control System (VCS) is a tool that helps manage changes to source code over time. It keeps track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members. It is critical for collaborative software development, but it also introduces unique security challenges:

- **Code Integrity**: Ensuring that code changes are not maliciously altered.
- **Access Control**: Managing who can read from and write to the repository.
- **History Protection**: Protecting the commit history from unauthorized access or tampering.
- **Sensitive Information**: Ensuring that sensitive information (e.g., API keys, passwords) is not inadvertently committed to the repository.

### Common Weaknesses

Recognizing common weaknesses helps in detecting and mitigating them effectively. Below are some frequent vulnerabilities found in version control systems:

#### Insecure Webhooks

Version control systems often use webhooks to connect with external services. If these webhooks are not adequately protected by non-visible secrets, attackers can exploit them. For instance, without proper security, attackers can manipulate the webhook functionality. Even if a secret is embedded in the URL, it can still be vulnerable to exploitation.

#### Data Exposure

Sensitive information might unintentionally be included in code commits. If an unauthorized person accesses the repository, either because it is public or through unauthorized means, they could uncover these details.

#### Unauthorized Account Access

If an attacker gains access to a user account on the version control platform, they can obtain extensive permissions. This access may allow them to view and alter other repositories and configurations. Some platforms permit the creation of accounts by external users, or access via single sign-on (SSO) methods like GitHub.

#### Stolen Authentication Details

Various authentication details, such as usernames, passwords, personal access tokens, SSH keys, OAuth tokens, and cookies, can be compromised. Each of these provides different levels of access, which attackers can exploit to infiltrate repositories.

#### Code Compromise

A malicious actor with some level of write access to the repositories could inject malicious code. To be successful, they might need to bypass branch protections. These actions can have different goals:

- **Compromise the Main Branch**: The attacker could inject malicious code into the main branch to compromise the production environment.
- **Compromise Other Branches**: The attacker could inject malicious code into other branches to compromise developers' machines, as developers often run tests, Terraform scripts, or other code from these branches on their local machines.
- **Compromise the Pipeline**: By introducing malicious code into the repository, the attacker could also target the CI/CD pipeline, which might then execute the malicious code during its processes.

These exploits can lead to severe consequences, including data breaches, unauthorized access, and potential damage to the organization's infrastructure and reputation.

### Methodology

Penetration testing methodologies vary significantly across different Version Control Systems (VCS). Here‚Äôs a detailed approach for some popular VCS platforms, including specific techniques and commands for effective assessment. Understanding the unique characteristics of each VCS helps tailor the testing strategy to uncover and exploit vulnerabilities.

#### GitHub

1. **Information Gathering**: Begin by collecting data from public repositories. Utilize tools like [GitHub Dorking](https://github.com/techgaun/github-dorks) to search for sensitive information such as passwords or API keys within public repositories. For instance, searching for exposed API keys can reveal critical vulnerabilities:

```shell
site:github.com "password" -inurl:issues
```

This helps in identifying repositories that might have inadvertently exposed sensitive data in commits or documentation. By analyzing the results, you can pinpoint where sensitive information may have been leaked.

2. **API Analysis**: Next, leverage the [GitHub API](https://docs.github.com/en/rest) to enumerate users, organizations, and repositories. For example, listing organization members can reveal individuals with administrative privileges or access to sensitive repositories:

```shell
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/orgs/ORG_NAME/members
```

This step is crucial for understanding the access control and potential entry points for further exploitation.

3. **Configuration Review**: Inspect Webhooks and [GitHub Actions](https://docs.github.com/en/actions) for security misconfigurations. Checking webhook configurations can help identify exposed secrets or insecure scripts:

```shell
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/OWNER/REPO/hooks
```

Analyzing these configurations can highlight areas where security practices might be inadequate, allowing you to focus on these vulnerabilities.

4. **Exploitation**: During the exploitation phase, use any compromised API keys or tokens to access sensitive resources. For example, compromised tokens could be used to retrieve secrets from CI/CD workflows:

```shell
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/OWNER/REPO/actions/secrets
```

This phase often reveals critical weaknesses that can be leveraged to gain unauthorized access or escalate privileges.

5. **Post-Exploitation**: To maintain access, create new users or add SSH keys to your account. This ensures continued access even if initial vulnerabilities are patched:

```shell
curl -X POST -H "Authorization: token YOUR_TOKEN" -d '{"key": "ssh-rsa AAA..."}' https://api.github.com/user/keys
```

By securing your foothold, you prepare for potential cleanup or further exploitation activities.

Penetration testing a specific folder or directory within a GitHub repository requires a tailored approach to identify vulnerabilities or insecure configurations. Here are additional techniques to focus on when targeting a specific directory within a GitHub repository:

#### For a Specific GitHub Folder

1. **Directory Listing**: Check for exposed directories or files within a repository. Use GitHub's own search capabilities or tools like [GitGutter](https://github.com/aurora/gitgutter) to locate specific files or directories that may contain sensitive information.

- **Example Query**:

```shell
site:github.com "config" repo:USERNAME/REPO_NAME
```

2. **File Content Inspection**: Manually review files within the target directory for sensitive data. Look for configuration files, scripts, or documentation that might reveal secrets. Focus on files such as `.env`, `config.json`, or any files commonly used to store credentials.

- **Example Check**:
    Navigate to the folder in the GitHub web interface or use the GitHub API to download specific files:

```shell
curl -H "Authorization: token YOUR_TOKEN" -L https://raw.githubusercontent.com/OWNER/REPO_NAME/main/path/to/file
```

3. **History Analysis**: Analyze the commit history for changes to files within the folder. Look for commits that introduce sensitive information or configurations. Use `git log` to find relevant commits and `git diff` to view changes.

- **Example Commands**:

```shell
git log --oneline -- path/to/folder
git diff <commit1> <commit2> -- path/to/folder
```

4. **Configuration Files Review**: Examine configuration files for security flaws. Look for hardcoded credentials, improper access controls, or insecure settings. Files like `docker-compose.yml`, `.travis.yml`, and `.gitlab-ci.yml` are worth checking.

- **Example**:
    Check the contents of `docker-compose.yml` for exposed secrets:

```shell
curl -H "Authorization: token YOUR_TOKEN" -L https://raw.githubusercontent.com/OWNER/REPO_NAME/main/docker-compose.yml
```

5. **Webhook and GitHub Action Exploitation**: Investigate if webhooks or GitHub Actions are configured to execute scripts or commands. Check if these configurations are vulnerable to injection or unauthorized modifications.

- **Example**:
    Retrieve and inspect webhook configurations:

```shell
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/OWNER/REPO_NAME/hooks
```

6. **Secret Scanning**: Use tools designed to scan for secrets within a specific folder. Tools like [TruffleHog](https://github.com/trufflesecurity/trufflehog) or [Gitleaks](https://github.com/zricethezav/gitleaks) can be configured to focus on particular directories to uncover any exposed secrets.

- **Example Usage**:

```shell
trufflehog --repo=https://github.com/OWNER/REPO_NAME --path=path/to/folder
gitleaks --repo=https://github.com/OWNER/REPO_NAME --path=path/to/folder
```

7. **Code Review for Hardcoded Secrets**: Perform a thorough review of code files within the folder to identify any hardcoded secrets or sensitive information. Look for credentials, API keys, or tokens in source code.

- **Example**:
    Use `grep` to search for common sensitive patterns:

```shell
grep -r "password\|apikey\|secret" path/to/folder
```

8. **Access Control Review**: Verify the access control settings for files and directories within the repository. Check if any files have incorrect permissions or are accessible to unauthorized users.

- **Example**:
    Review file permissions using GitHub‚Äôs web interface or APIs to ensure that sensitive files are not publicly accessible.

9. **Dependency Analysis**: Inspect dependencies listed in files like `package.json`, `requirements.txt`, or `pom.xml` for known vulnerabilities. Dependencies with known issues can be exploited if they are misconfigured or outdated.

- **Example**:
    Use tools like [Dependabot](https://github.com/dependabot) or [Snyk](https://snyk.io/) to automatically detect vulnerabilities in dependencies.

#### GitLab

1. **Information Gathering**: Start by exploring public projects using [GitLab Dork](https://gitlab.com/gitlab-com/gl-security/security-operations/gl-security-operations/-/issues/107) to find sensitive information. You might use specific queries to uncover exposed credentials:

```shell
site:gitlab.com "api_key" -inurl:issues
```

This process helps identify publicly accessible data that could pose security risks.

2. **Pipeline Analysis**: Proceed by examining pipeline configuration files such as `.gitlab-ci.yml` for vulnerable scripts. For instance, a script that makes an insecure HTTP request could be exploited:

```yaml
script:
  - curl -X POST -H "Content-Type: application/json" -d '{"data":"example"}' http://example.com
```

This analysis helps identify areas where pipeline configurations might be insecure.

3. **Permissions Review**: Evaluate user roles and permissions to detect excessive permissions or misconfigurations. Listing users and their roles in projects can reveal potential security gaps:

```shell
curl -H "Authorization: Bearer YOUR_ACCESS_TOKEN" https://gitlab.com/api/v4/groups/GROUP_ID/members
```

Identifying these gaps is essential for understanding the scope of access available for exploitation.

4. **Exploitation**: Utilize insecure CI/CD scripts to execute arbitrary commands. For example, triggering pipelines with malicious payloads can compromise systems:

```shell
curl -X POST -H "Authorization: Bearer YOUR_ACCESS_TOKEN" https://gitlab.com/api/v4/projects/PROJECT_ID/trigger/pipeline
```

This phase helps demonstrate how vulnerable scripts can be leveraged for unauthorized actions.

5. **Post-Exploitation**: Create high-permission users or modify existing configurations to ensure ongoing access:

```shell
curl -X POST -H "Authorization: Bearer YOUR_ACCESS_TOKEN" -d '{"email": "newuser@example.com", "password": "newpassword"}' https://gitlab.com/api/v4/users
```

Securing continued access and maintaining control post-exploitation are key to ensuring the efficacy of your testing efforts.

#### BitBucket

1. **Information Gathering**: Begin by searching for sensitive information in public repositories using tools like [Bucket Stream](https://github.com/eth0izzle/bucket-stream). For example, analyzing commits and configuration files might reveal confidential data:

```shell
bucket-stream -u https://bitbucket.org/user/repo
```

Identifying this information can provide insights into potential vulnerabilities.

2. **Configuration Analysis**: Review repository permissions and branch settings to uncover potential security issues. For instance, listing repository permissions can reveal weak settings:

```shell
curl -u username:password https://bitbucket.org/!api/2.0/repositories/{username}/{repo_slug}/permissions
```

This helps in understanding the security posture of the repository and its configurations.

3. **Exploitation**: Use sensitive information found in repositories to access external services or exploit misconfigured Webhooks to inject malicious code. For example:

```shell
curl -X POST -d '{"payload": "data"}' https://example.com/webhook
```

Exploiting these vulnerabilities can demonstrate the impact of weak configurations or exposed data.

4. **Post-Exploitation**: To maintain access, create new users or add SSH keys:

```shell
curl -X POST -u username:password -d '{"key": "ssh-rsa AAA..."}' https://bitbucket.org/!api/2.0/users/username/ssh-keys
```

Ensuring ongoing access and manipulating security settings are critical steps to solidify your testing results.

#### Gitea

1. **Information Gathering**: Explore public repositories for sensitive information. Look for exposed credentials or secrets in configuration files:

```shell
curl -u username:password https://gitea.com/api/v1/repos/{owner}/{repo}/contents
```

This helps in identifying sensitive data that could be exploited.

2. **Permission Evaluation**: Assess user roles and permissions to uncover potential security flaws. For example:

```shell
curl -u username:password https://gitea.com/api/v1/orgs/{org}/members
```

Understanding the permission structure is crucial for determining potential entry points.

3. **Configuration Review**: Check repository and branch configurations for security flaws. For instance:

```shell
curl -u username:password https://gitea.com/api/v1/repos/{owner}/{repo}/branches
```

Reviewing these settings helps identify misconfigurations that could be exploited.

4. **Exploitation**: Use sensitive information found in repositories to access external services or exploit misconfigured Webhooks. For example:

```shell
curl -X POST -d '{"payload": "data"}' https://example.com/webhook
```

This phase shows how sensitive data and weak configurations can be exploited.

5. **Post-Exploitation**: Maintain access by creating new users or adding SSH keys:

```shell
curl -X POST -u username:password -d '{"key": "ssh-rsa AAA..."}' https://gitea.com/api/v1/user/keys
```

These actions ensure continued access and control over the system.

#### Cloud Providers' VCS

1. **Information Gathering**: Use cloud provider APIs to gather information on repositories and configurations. For instance, use AWS CodeCommit API to list repositories:

```shell
aws codecommit list-repositories
```

Gathering this data helps in understanding the cloud environment's structure and potential vulnerabilities.

2. **Permissions Analysis**: Analyze users, roles, and permissions associated with repositories to find potential security gaps. For example:

```shell
aws iam list-users
```

Identifying misconfigured roles or excessive permissions is essential for discovering vulnerabilities.

3. **Configuration Review**: Inspect CI/CD pipelines and Webhook configurations for security vulnerabilities. For instance:

```shell
aws codepipeline get-pipeline --name pipeline-name
```

Reviewing these configurations helps in identifying potential weaknesses in the deployment process.

4. **Exploitation**: Exploit weak security settings or use sensitive data to access other cloud services. For example:

```shell
aws s3 ls --profile my-profile
```

This phase demonstrates the impact of weak security settings on broader cloud services.

5. **Post-Exploitation**: Modify roles or permissions to maintain access. For example:

```shell
aws iam attach-user-policy --policy-arn arn:aws:iam::aws:policy/AdministratorAccess --user-name username
```

Securing continued access and manipulating cloud security settings ensures a comprehensive assessment.

Each VCS platform presents unique features and potential vulnerabilities. Tailoring your approach to each system‚Äôs specific characteristics and security configurations is crucial. Tools like [TruffleHog](https://github.com/trufflesecurity/trufflehog), [Gitleaks](https://github.com/zricethezav/gitleaks), and [Gitrob](https://github.com/michenriksen/gitrob) can automate the discovery of sensitive data and configuration issues, streamlining the penetration testing process and enhancing the effectiveness of your security assessments.

## Pipelines Pentesting

A pipeline in software development is a series of automated processes that move code from development to production. For instance, when developers push code to a repository, the pipeline can automatically build the code, run tests, and deploy it to a staging environment. This automation ensures that every change is thoroughly tested and deployed efficiently, reducing errors and speeding up delivery.

Securing your CI/CD pipeline is crucial for maintaining the integrity, confidentiality, and availability of your software development process. An insecure pipeline can serve as a gateway for attackers to introduce malicious code, steal sensitive information, or disrupt operations. By implementing robust security measures, you protect your codebase from unauthorized access, ensure that only validated changes are deployed, and safeguard your software from potential vulnerabilities that could be exploited in production environments. This proactive approach not only enhances the overall quality and reliability of your software but also helps in complying with industry regulations and standards.

### Common Vulnerabilities

#### Broken Authentication in CI/CD

Oversights in the design of authorization and authentication for CI/CD channels can lead to significant vulnerabilities. Properly validating the role and permission scheme is crucial to prevent unauthorized access and actions. Some common issues include:

##### Adding Unauthorized Approver Using Admin Permissions

**ci-tool** is a command-line utility designed for interacting with and managing CI/CD pipelines. In the context of penetration testing for Version Control Systems (VCS), **ci-tool** can be particularly useful for exploring and manipulating pipeline configurations and permissions.

An attacker with administrator permissions on the CI channel can use **ci-tool** to perform actions such as adding unauthorized users as approvers. This bypasses necessary security checks and can potentially allow the attacker to approve or deploy changes without proper oversight. For instance:

```shell
ci-tool add-approver --pipeline pipeline-name --user unauthorized-user
```

**Weak Authentication**

Attackers exploit weak authentication mechanisms to gain administrator access to the CI tool and manipulate settings, often using brute force attacks. For example:

```shell
ci-tool login --username admin --password weakpassword
```

**Token Manipulation**

Attackers can use stolen tokens to perform unauthorized actions. For example:

```shell
ci-tool --api-token stolen-token add-approver --pipeline pipeline-name --user unauthorized-user
```

#### Poor Handling of Secrets

Pipelines frequently connect to resources requiring sensitive credentials. Proper secret management is essential to prevent exploitation. Common issues include:

**Incorrect Repository Authorization**

An attacker accesses a CI/CD pipeline interacting with a secret manager and exploits weak permissions to retrieve sensitive credentials. For example:

```shell
ci-tool get-secrets --repository malicious-repo --secret-manager secretmanager-name
```

**Code Injection**

Attackers submit malicious code to a legitimate repository, capturing or exploiting secrets during pipeline execution. For example:

```shell
echo "print(password)" >> main.py
```

**Retrieving Credentials from CI/CD Admin Console**

Attackers can access AWS and secret keys from a CI/CD admin console and pass them as environment variables. For example:

```shell
export AWS_ACCESS_KEY_ID=$(aws ssm get-parameter --name /path/to/access_key --with-decryption --query Parameter.Value --output text)
export AWS_SECRET_ACCESS_KEY=$(aws ssm get-parameter --name /path/to/secret_key --with-decryption --query Parameter.Value --output text)
pipeline-stage-command
```

**Retrieving a Secret from Hashicorp Vault**

Secrets can be retrieved from Hashicorp Vault and passed as variables to the pipeline stage. For example:

```shell
export SECRET=$(vault kv get -format=json secret/path/to/secret | jq -r '.data.key')
pipeline-stage-command
```

**Retrieving a Secret from Kubernetes**

Secrets can be retrieved from Kubernetes and passed as a mounted volume in the pipeline stage. For example:

```shell
kubectl create secret generic my-secret --from-literal=username=<username> --from-literal=password=<password>
kubectl create volume secret my-secret-volume --secret=my-secret
pipeline-stage-command --volume=my-secret-volume:/secrets
```

#### Production Environment Exposed Due to Poor Configuration

Misconfigurations in CI/CD pipeline settings can expose the production environment to various risks. Common issues include:

**Misconfigured Environment Variables**

Poorly configured environment variables can be exploited to gain unauthorized access to resources. For example:

```shell
ci-tool get-secrets --repository legitimate-repo --secret-manager $MISCONFIGURED_VARIABLE
```

**Modification of Unauthorized Configuration**

Attackers can modify production environment configurations if they gain access to the pipeline. For example:

```shell
echo "MALICIOUS_SETTING = True" >> production.config
```

**Misconfigured Scripts**

Poorly configured scripts can be exploited to alter the production environment. For example:

```shell
ci-tool run-deployment-script --script "sed -i 's/ALLOW_PUBLIC_ACCESS = False/ALLOW_PUBLIC_ACCESS = True/' production.config"
```

**Insecure Configuration Manager**

Improper input validation in configuration managers can allow command injection. For example, an attacker could add `rm -rf /` to delete the entire filesystem.

#### Insecure Credential Storage

Insecure storage of credentials in the pipeline can lead to unauthorized access. For example, if AWS credentials are stored insecurely, an attacker can retrieve them with a command like:

```shell
cat ~/.aws/credentials
```

### Methodology

The most common way to define a pipeline is by using a CI configuration file hosted in the repository the pipeline builds. This file describes the order of executed jobs, conditions affecting the flow, and build environment settings. These files typically have a consistent name and format, such as Jenkinsfile (Jenkins), `.gitlab-ci.yml` (GitLab), `.circleci/config.yml` (CircleCI), and the GitHub Actions YAML files located under `.github/workflows`. When triggered, the pipeline job pulls the code from the selected source (e.g., commit/branch) and runs the commands specified in the CI configuration file against that code.

Pipelines automate the process of building, testing, and deploying software. This course covers pentesting methodologies for three popular pipeline tools: Terraform, Jenkins, and Apache Airflow.

#### Terraform

Terraform is an open-source Infrastructure as Code (IaC) tool developed by HashiCorp. It allows users to define and provision infrastructure using a high-level configuration language called HashiCorp Configuration Language (HCL), or optionally JSON. With Terraform, you can manage a wide range of infrastructure components, including physical machines, virtual machines, networking, storage, and even software and services.

**Review Terraform Configuration Files**

Start by examining Terraform configuration files (typically .tf files). Look for sensitive information such as hard-coded secrets, API keys, and passwords. Analyze the files for insecure configurations or misconfigurations that could lead to security vulnerabilities.

**Validate and Test the Configuration**

Use Terraform's built-in commands like `terraform validate` and `terraform plan` to identify potential issues in the configuration. These commands can help detect syntax errors and logic flaws.

**Assess State Files**

Terraform state files (terraform.tfstate) contain detailed information about the infrastructure. Ensure that these files are stored securely, as they may contain sensitive data. Check for any state file mismanagement, such as storing them in unsecured locations.

**Check for Drift and Security Best Practices**

Run `terraform plan` regularly to check for drift between the actual infrastructure and the desired state defined in the configuration. Ensure that best practices for security, such as using least privilege for IAM roles and encrypting sensitive data, are followed.

#### Jenkins

Jenkins is an open-source automation server widely used for continuous integration (CI) and continuous delivery (CD). It automates the process of building, testing, and deploying software, enabling developers to deliver high-quality software more efficiently.

**Analyze Jenkinsfile and Job Configurations**

Start by reviewing the Jenkinsfile and job configurations. Look for credentials, secrets, and sensitive data hard-coded into the pipelines. Ensure that sensitive information is handled securely, using Jenkins credentials plugins where appropriate.

**Examine Plugins and Dependencies**

Review the installed plugins and their versions. Outdated or vulnerable plugins can be exploited. Ensure that only necessary plugins are installed and that they are kept up to date.

**Check Access Controls and Permissions**

Assess the user roles and permissions configured in Jenkins. Ensure that the principle of least privilege is enforced and that sensitive jobs are restricted to authorized users only.

**Review Build Artifacts and Logs**

Examine build artifacts and logs for sensitive information. Ensure that logs do not expose credentials or other sensitive data and that artifacts are stored securely.

#### Apache Airflow

Apache Airflow is an open-source platform used to programmatically author, schedule, and monitor workflows. It is designed to help organizations manage complex workflows and data processing pipelines by providing a robust and flexible orchestration engine.

**Analyze DAGs and Python Scripts**

Start by reviewing the Directed Acyclic Graphs (DAGs) and associated Python scripts. Look for hard-coded credentials, secrets, and sensitive data within the code. Ensure that sensitive information is managed securely.

**Assess Airflow Configuration**

Review the Airflow configuration files (airflow.cfg). Check for insecure configurations, such as weak authentication methods or exposed endpoints. Ensure that the configuration follows security best practices.

**Check Access Controls and Permissions**

Assess the user roles and permissions configured in Airflow. Ensure that sensitive DAGs and tasks are restricted to authorized users only. Verify that the principle of least privilege is enforced.

**Monitor Logs and Task Outputs**

Examine logs and task outputs for sensitive information. Ensure that logs do not expose credentials or other sensitive data and that task outputs are stored securely.

## Tools that can help

To aid in penetration testing and automate certain tasks, various specific tools can be used. These tools help streamline the testing process, identify vulnerabilities, and ensure security best practices are followed.

**[Burp Suite](https://portswigger.net/burp)** is a comprehensive tool for web application security testing. It is particularly useful for testing web interfaces and APIs used in pipelines. For example, it can test CI/CD pipeline web interfaces by intercepting and modifying traffic to find vulnerabilities. Similarly, **[OWASP ZAP](https://www.zaproxy.org/)**, an open-source web application security scanner, can automate the process of finding security vulnerabilities in web interfaces, making it essential for testing APIs and webhooks used in pipelines.

For static analysis of **Terraform** code, **[TFSec](https://github.com/aquasecurity/tfsec)** scans for potential security issues and misconfigurations, providing detailed reports on insecure configurations. Similarly, **[Checkov](https://www.checkov.io/)** performs static code analysis for Infrastructure as Code (IaC) to identify misconfigurations in cloud infrastructure managed by tools like Terraform, CloudFormation, and Kubernetes.

**[InSpec](https://github.com/inspec/inspec)** allows for the writing of automated tests for security and compliance directly within infrastructure code, enabling continuous compliance checks as part of the CI/CD pipeline. **[Bandit](https://github.com/PyCQA/bandit)** is a security linter for Python code, designed to find common security issues in the Python scripts used in various pipelines, ensuring that scripts do not introduce vulnerabilities.

In the Jenkins environment, security plugins such as the **[OWASP Dependency-Check Plugin](https://plugins.jenkins.io/dependency-check-jenkins-plugin/)** identify vulnerabilities in project dependencies, alerting developers to insecure libraries. The **[Script Security Plugin](https://plugins.jenkins.io/script-security/)** ensures that Groovy scripts running in a Jenkins instance are secure, preventing unauthorized or malicious code from executing. The **[Configuration as Code Plugin](https://plugins.jenkins.io/configuration-as-code/)** allows Jenkins configurations to be defined as code, ensuring consistent application of security best practices and making it easier to review and manage configurations securely.

To complement the tools mentioned above, widely-known tools like Metasploit and Nmap can also be highly effective. Even though they are commonly used for general penetration testing, they can be equally valuable in identifying vulnerabilities and assessing the security posture of VCS and CI/CD environments.

## Resources

- [How to start a pentest from your CI/CD pipeline](https://help.getastra.com/en/article/how-to-start-a-pentest-from-your-cicd-pipeline-1la2axv/)
- [CI/CD secrets extraction Tips & Tricks](https://www.synacktiv.com/publications/cicd-secrets-extraction-tips-and-tricks)
